#+TITLE: Learn Rust: hack without fear!
#+SETUPFILE: ~/Notes/common.org
#+SETUPFILE: ~/Notes/latex.org
#+SETUPFILE: ~/Notes/coding.org

* Memo [0/6]
** TODO [2018-02-02 Fri] 错误处理
- [[https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-][A Shortcut for Propagating Errors: ?]]

** [2018-02-01 Thu] Eq与PartialEq
- [[https://doc.rust-lang.org/std/cmp/trait.PartialEq.html][std::cmp::PartialEq - Rust]]
- [[https://doc.rust-lang.org/std/cmp/trait.Eq.html][std::cmp::Eq - Rust]]
- [[https://doc.servo.org/core/cmp/trait.Ord.html][core::cmp::Ord - Rust]]

Eq是PartialEq的加强版.

PartialEq不要求自相等. 比如: a可以不等a(以浮点数为例).

** [2018-01-31 Wed] 使用petgraph来操作图论结构
第一印象: 没有networkx的api那么方便.

有三种graph类型.

*** Graph
: let node_index = G.add_node(weight);
这和networkx的语法不同, add_node的参数是weight, 不是node数据. 返回值为node_index.

: let edge_index = G.add_edge(n1, n2, edage_data);
n1, n2为node_indices, edage_data可为任意数据类型. 返回值为edge_index

: let node_weight = &G[node_index];
: let edge_weight = &G[edge_index];
有了indices, 可以方便地访问graph节点和边关联的数据.

add_edge时需注意:默认petgraph充许parallel edges, 因此多次添加edge时, 会生成两个
节点间的多个边. 使用update_edge函数可避免这个问题.
*** GraphMap
这个更接近于networkx中的Graph对象的实现方式. 基于petgraph作者写的[[https://github.com/bluss/ordermap][ordermap]] (后续
可能会换名字: IndexMap).

不充许parallel-edge(两个不同节点间有多条边), 但充许有self-loop(同一节点间形成的
边).

: G.add_node(n);
其中n用来指示不同的node. 不能设定node data, 或者说n本身就是data(结构体).

: G.add_edge(n1, n2, edge_data);
添加节点n1和n2之间的边.

*** StableGraph

** TODO [2018-01-28 Sun] 使用nom解析格式化文件
- [[https://stevedonovan.github.io/rust-gentle-intro/nom-intro.html#parsing-text-with-nom][Parsing with Nom - A Gentle Introduction to Rust]]
- [[http://rust.unhandledexpression.com/nom/][nom - Rust]]

nom的优点:
- 解析单元可自由组合 (parser combinator library)
- 容易调试, 容易集成. 方便实现更复杂的解析逻辑
- 比regex更快.

** [2018-01-19 Fri] 文件读写
- [[https://doc.rust-lang.org/std/fs/struct.File.html][std::fs::File - Rust]]
- [[https://doc.rust-lang.org/std/io/index.html][std::io - Rust]]
- [[https://doc.rust-lang.org/std/io/struct.BufReader.html][std::io::BufReader - Rust]]

*** reader.read_line
需要string参数. 将新读入的一行数据附加到buf中. 返回读入的字节数.

** [2018-01-18 Thu] Result和Option类型
Result枚举类型是对所有返回值的完全分类：正常（Ok）或出错（Err）。Option枚举类型
是对所有可选项的完全分类，有值（Some）或无值（None）。

Result和Option经常用于匹配参数返回不同数据上（match）。

Reference
- [[https://doc.rust-lang.org/std/result/][std::result - Rust]]
- [[https://doc.rust-lang.org/std/option/][std::option - Rust]]

** [2018-01-18 Thu] [[https://blog.rust-lang.org/2017/12/21/rust-in-2017.html][Rust in 2017: what we achieved]]
感觉上是python和C的完美结合.

- [[https://github.com/rust-lang-nursery/tempdir][rust-lang-nursery/tempdir: Temporary directory management for Rust]]
- [[https://github.com/rayon-rs/rayon][rayon-rs/rayon: Rayon: A data parallelism library for Rust]]

** TODO [2018-01-17 Wed] 使用log工具
- [[https://github.com/rust-lang-nursery/log][rust-lang-nursery/log: Logging implementation for Rust]]

log将和slog合并: [[https://github.com/rust-lang-nursery/log/issues/149][Structured Logging · Issue #149 · rust-lang-nursery/log]]

** [2018-01-17 Wed] rust基础练习4: 简单命令行界面
可以使用std::env来提取. env::args返回的是Iterator, 其中每个参数都为string类型.

复杂点的可以用[[https://github.com/kbknapp/clap-rs][clap]].

** [2018-01-01 Mon] rust ownership :ATTACH:
:PROPERTIES:
:ID:       dfcf2ff4-7214-483f-8b66-bf76a0372e8a
:Attachments: rust-intro-2018-01-01142409_2018-01-01_14-26-11.png
:END:

#+DOWNLOADED: @ 2018-01-01 14:26:11
#+attr_org: :width 600
#+attr_odt: :width 8
[[file:data/df/cf2ff4-7214-483f-8b66-bf76a0372e8a/rust-intro-2018-01-01142409_2018-01-01_14-26-11.png]]

** TODO [2017-12-30 Sat] 完成[[http://exercism.io/languages/rust/exercises][exercism.io]]上的练习
** TODO [2017-12-30 Sat] 使用rust来完成之前写的lindermann指数计算程序
** [2017-12-26 Tue] rust基础练习3 基本数据结构
*** tuple
: tuples like (1, true)
- tuple中的数据可以是不同类型的.
- 通过tuple, 函数可以返回多个数值.

tuple输出时:
: println("{:?}", (1, 2));

tuple可以通过位置来指认:
#+name: 7db31524-8474-431d-8e3c-279dd552c4e3
#+begin_src rust
  let t = (1, 2);

  print!("{}, {}", t.0, t.1);
#+end_src

可以像python一样, 可以把tuple展开给多个变量:
#+name: efd8cd2d-26a7-47da-a4ab-841a2f6a1396
#+begin_src rust
  let t = (1, 2, 3);
  let (a, b, c) = t;
#+end_src
注意左侧的变量要用tuple的形式括起来, 否则会报错. 这也python不同.

注意tuple引用内部成员时不能使用变量, 也不能像python的那样来取值. 下面的语句是错的:
: let t = (12, 2, 'a');
: let i = 1;
: println! ("{}", t.i);  // 错误
: println! ("{}", t[0]); // 错误

只有一个成员的tuple, 后面的逗号不能省略:
: let t = (12,);

无成员类型:
: let t = ();

函数无返回值时, 默认返回(), 相当于python中的None?

*** arrays, slices
: arrays like [1, 2, 3]
rust中的array和C里的静态数组类似, 成员类型要一致, 运行时不可增删.
#+name: 263760d4-6182-4794-8e27-704b2aa61a31
#+begin_src rust
  let arr = [1, 2, 5, 9, 10];
  println!("{}", arr[0], array[2]);
#+end_src
如何访问数组成员越界, rust在编译时就会报错.

成员函数:
: arr.len();
: arr.sort();

数组声明时, 要指明成员数值类型及成员数:
: let arr: [i32; 5] = [1, 2, 3, 4, 6];
注意中间用的是分号.
: let arr: [i32; 500] = [12; 500];
注意右侧的值为500个12.

如果要使用range来提取多个数值, 需要取址, 用slice:
: &arr[1..5]

二维数组:
#+name: ec1673bf-357a-475c-bb95-ff63fe463bc2
#+begin_src rust
  let arr = [[1, 5], [2, 4]];
  println!("{:?}", arr[0][1]);
#+end_src

slice在运行期才能知道数组的大小, 为了避免panic, 可以用slice.get方法
#+name: f9bd3ee7-0cce-4adc-a0da-cf3a440101b4
#+begin_src rust
  let arr = [1, 2, 3, 4];
  let slice = &arr;
  let last = slice.get(5);
#+end_src
这与python中的dict.get类似. slice访问如果越界, 会返回一个特殊的数据结构Option,
值为None.

Option对象可用函数:
: last.is_some();
: last.is_none();
如果opt有值, 可以提出来:
: last.unwrap();
如果opt是None, unwrap的话运行时会panic.

更便捷的方式是使用unwrap_or
: last.unwrap_or(&-1)
注意参数用&取址.

注意last.unwrap()取出的数据为reference, 不是实在的数据. 记得根据需求解引:
: *last.unwrap()
*** vector
vector是动态数组, 同array一样, 成员类型要一致.

声明变量:
: let v = vec![2, 3, 1, 5];
或者:
: let v = Vec::new();
: v.push(2);
: ...

可以从iterator初始化:
: let v:Vec<i32> = (0..5).collect();
注意v要指明类型.

添加元素:
: v.push(1);

插入元素:
: v.insert(1, 'a');

删除元素:
: v.remove(1);

*** string
**** char
单引号: char
双引号: literal string

**** str, string literal
双引号中的为literal string (&'static str). literal string为静态数据类型, 就像是整型, 浮点型.

中间可以包括硬回车或转义字符.
#+name: c0f6ce7f-deac-4321-9c14-4312a9518957
#+begin_src rust
  let s = "good to go\n";

  let s = "good
  to go";

  // s = good togo
  let s = "good to\
           go";
#+end_src
字串中可以使用~\~来续行.

raw string:
#+name: 3de9f418-5b32-42b6-bf5c-6285b458ad7c
#+begin_src rust
  // s = "\n\n"
  let s = r"\n\n";
#+end_src

lieral string可用的函数:
: s.len();
与python不同, rust中的string不能index, 比如s[0], 但可以slice:
#+name: 7a55e292-1387-4cdc-8f05-14e9ed00c888
#+begin_src rust
  let s = "abcdef";
  let subs = &s[1..2]
#+end_src

**** String
内存动态分配的string.

[[https://doc.rust-lang.org/std/string/struct.String.html][std::string::String - Rust]]

A UTF-8 encoded, growable string

初始化:
: let s = String::new();
: let s = String::from("world");
: let s = "Hello".to_string();

修改字串:
string.push, string.push_str, string.pop, string.remove, string.insert, string.insert_str, string.truncate, string.clear
: s.push('1');
: s.push('好');
: s.push_str("bar");

可以像python一样, 使用"+"来合并字串:
#+name: 9e15f850-01c6-4368-b21e-fe560b347feb
#+begin_src rust
  let mut s = "good to go to do".to_string();
  s.push('d');
  println!("{}", s + "good");
#+end_src

使用format! macro来生成格式化字符串.
#+name: 21f9c2a1-d351-468e-a414-c37f018903df
#+begin_src rust
  let s = format!("{}", 2.2);
#+end_src

合并字串
#+name: 425fe069-3e10-417a-8929-2551b7417db2
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.concat();
#+end_src

像python中的str.join
#+name: f91f9154-1da8-4788-a969-dc72a2e281c1
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.join("\n");
#+end_src

取子串:
: s.chars()

其它:
contains, replace, trim, split

测试:
string.contains, string.starts_with, string.ends_with, string.find

其它:
string.split, string.trim, string.repeat
: assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));

iteration
string.chars

&string: shared reference to string
&str: string slice
*** TODO hash maps
- [[https://doc.rust-lang.org/book/second-edition/ch08-03-hash-maps.html][Hash Maps - Hash Maps - The Rust Programming Language]]

*** TODO structs
这个像namedtuple, C里的结构体. 通名称来指认内部成员更方便些.

** [2017-12-21 Thu] rust基础练习2 control flow
#+name: 5fde93b8-94a6-4341-9db8-f3625238dfc5
#+BEGIN_SRC rust
  if (a < b) {
      println!("{}", 1);
  } else {
      println!("{}", 2);
  }
#+END_SRC

如果是多个条件:
: else if

注意if等判断语句后跟bool类型. rust不会像python做隐式类型转换. 比如下面的语句会报错:
#+name: be800e54-711b-4393-aefb-811c41ba2b7a
#+begin_src rust
  let r = 1;
  if r {...};
#+end_src

也可以像python写成单行表达式
#+name: 632a594b-c4a8-48db-ab4d-f176d44954b2
#+BEGIN_SRC rust
  let y:f64 = if a < 4. {1.} else {2.}
#+END_SRC
此时要注意, else前后的返回值类型要一致, 否则会报错.

循环结构可以用loop, while, for. break/continue同样可用.

对于多层循环, rust中可以使用标签, 然后break到指定位置. 见[[https://rustbyexample.com/flow_control/loop/nested.html][doc]].

rust使用match来实现像C里的switch语句类似的功能.

** [2017-12-20 Wed] rust基础练习1 变量常量类型
常量定义:
: let sum = 0;

变量定义:
: let mut sum = 0;

上面的sum变量被定义为整型, 可以加和整型数据.

如果sum定义为浮点数:
: let mut sum = 0.;
: sum += 1;
自加和整型数1会报错. 需要对1进行显式的类型转换:
: sum += 1 as f64;
或者:
: sum += 1_f64;

如果是变量必须用"as f64"
: sum += i as f64;

rust对数值类型要求很严, 整数除以浮点数会报错
: 12/2.

整数除以整数会得到一个整数:
: 13/6
上面的值为2

常见的数值类型: i32, i64, u32, u64, f32, f64

rust避免做任何假设, 这倒是免掉了C里面的不少坑.


常见数值运算: [[https://doc.rust-lang.org/std/primitive.f64.html][docs]]
: x.abs()
: x.powf(2.)
: x.sqrt()

#+name: dac3cc9f-d575-49e3-a759-49a1f88224e8
#+BEGIN_SRC rust
  for i in 0..5 {
      println!("loop {}", i);
  }
#+END_SRC

loop变量不需要显式定义.

自定义函数:
#+BEGIN_EXAMPLE
fn sqrt(x: f64) -> f64 {
  return x*x;
}
#+END_EXAMPLE
函数返回值以最后一个语句为准, 因此return可以略去(同时去掉最后的分号).

** TODO [2017-12-12 Tue] 使用rust实现之前写的files-coder
- [[https://github.com/hyperium/mime/][hyperium/mime: MIMEs in Rust]]

** [2017-12-10 Sun] 使用cargo来管理rust程序
: cargo new test1 --bin

: cargo run
快速语法检查:
: cargo check

测试:
: cargo test
测试时允许print语句输出:
: cargo test -- --nocapture

* cargo
#+name: 7935cdce-84b1-4d22-a63d-7d0a8580a279
#+BEGIN_SRC conf :tangle Cargo.toml
  [package]
  name = "test1"
  version = "0.1.0"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  base64 = "*"
  clap = "*"
  zip = "*"
  nom = "*"
  petgraph = "*"

#+END_SRC

* tests [0/0]
** scratch
#+name: 26fc6fdf-a306-4357-aa27-ceeb00164a2d
#+begin_src shell :results output
  cargo run
#+end_src

#+RESULTS: 26fc6fdf-a306-4357-aa27-ceeb00164a2d

** hamming distance
*** test
#+name: 18144448-0970-4f66-bbd3-f206635ba2cf
#+begin_src shell :results output
  cd exercism/rust/hamming
  cargo test -- --nocapture
#+end_src

#+RESULTS: 18144448-0970-4f66-bbd3-f206635ba2cf
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 7 tests
test test_first_string_is_longer ... ok
test test_complete_hamming_distance_in_small_strand ... ok
test test_larger_distance ... ok
test test_no_difference_between_empty_strands ... ok
test test_no_difference_between_identical_strands ... ok
test test_second_string_is_longer ... ok
test test_small_hamming_distance_in_the_middle_somewhere ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/hamming/src/lib.rs
:END:

#+name: 86e0273f-d292-4c9a-a644-a82b07625639
#+begin_src rust
  pub fn hamming_distance(s1: &str, s2: &str) -> Result <usize, String> {
      if s1.len() != s2.len() {
          return Err("err".to_string())
      } else {
          let l = get_hamming_distance(s1, s2);
          Ok(l)
      }
  }

  fn get_hamming_distance(s1: &str, s2: &str) -> usize {
      assert_eq!(s1.len(), s2.len());

      let mut sum = 0;
      for (c1, c2) in s1.chars().zip(s2.chars()) {
          if c1 != c2 {
              sum += 1;
          }
      }
      sum
  }
#+end_src

** reverse string
*** test
#+name: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_src shell :results output
  cd exercism/rust/reverse*
  cargo test
#+end_src

#+RESULTS: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 5 tests
test test_a_capitalized_word ... ignored
test test_a_palindrome ... ignored
test test_a_sentence_with_punctuation ... ignored
test test_a_word ... ignored
test test_empty_string ... ok

test result: ok. 1 passed; 0 failed; 4 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/reverse-string/src/lib.rs
:END:

#+name: 3d017385-a2ca-49af-8494-9b2dd4569f24
#+begin_src rust
  pub fn reverse(s: &str) -> String {
      s.chars().rev().collect::<String>()
  }
#+end_src

* reaction
分析lammps生成的轨迹文件.

** cargo
#+name: d5f68605-90cb-4b2b-b316-2025d935c17b
#+BEGIN_SRC conf :tangle reaction/Cargo.toml
  [package]
  name = "reac"
  version = "0.1.0"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  petgraph = "*"
  clap = "*"
#+END_SRC

** src
:PROPERTIES:
:header-args: :tangle reaction/src/main.rs
:END:
*** globals
#+name: 68b8f3aa-b3f8-43c0-8b4d-c3165b146535
#+begin_src rust
  extern crate petgraph;
  extern crate clap;

  use std::fs::File;
  use std::error::Error;
  use std::io::{self, BufReader};
  use std::io::prelude::*;
  use std::collections::HashMap;
  use std::path::Path;

  use petgraph::prelude::*;
  use petgraph as pg;
#+end_src

*** atoms
**** guess element from masses
LAMMPS的data文件中只有Masses信息. 从mass猜element太麻烦了, 直接读Masses部分中相
应的注释吧.

#+name: 66a225cc-1a72-4cb5-9dd1-94653871beba
#+begin_src rust :tangle no
  fn guess_element_from_mass(mass: f32) {
      ;
  }
#+end_src

**** 定义最简单的原子结构信息.
#+name: 1f84ef01-7ddb-4295-8521-c29ad7d7e059
#+begin_src rust
  use std::hash::{Hash, Hasher};
  use std::cmp::Ordering;

  #[derive (Default, Debug, Clone, Copy)]
  /// simple atom data structure
  pub struct Atom {
      pub index: u64,
      pub symbol: &'static str,
  }

  impl PartialEq for Atom {
      fn eq(&self, other: &Atom) -> bool {
          self.index == other.index
      }
  }

  impl Eq for Atom {}

  impl Hash for Atom {
      fn hash<H: Hasher>(&self, state: &mut H) {
          self.index.hash(state);
      }
  }

  impl Ord for Atom {
      fn cmp(&self, other: &Atom) -> Ordering {
          self.index.cmp(&other.index)
      }
  }

  impl PartialOrd for Atom {
      fn partial_cmp(&self, other: &Atom) -> Option<Ordering> {
          Some(self.cmp(other))
      }
  }

  #[test]
  fn test_atom() {
      let a = Atom{
          index: 1,
          symbol: "H",
      };

      let b = Atom {
          index: 2,
          symbol: "H",

      };
      let mut c = Atom {
          index: 1,
          symbol: "H",
      };

      assert!(a != b);
      assert!(a == c);

      assert!(a.index == 1);
      assert!(a.symbol == "H");

      c.symbol = "C";
      assert!(c.symbol == "C");
  }
#+end_src

**** 实现从元素符号列表到分子式.
#+name: 27fa4abe-d98c-4dd4-8695-e4b4f807cabc
#+begin_src rust
  // it is better to use generics function,
  // but it is really difficult for me now
  fn get_reduced_formula(symbols: &[&str]) -> String {
      // 1. count symbols: CCCC ==> C 4
      let mut counts = HashMap::new();
      for x in symbols {
          let c = counts.entry(x).or_insert(0);
          ,*c += 1;
      }

      let mut syms: Vec<String> = Vec::new();
      let mut to_append = String::new();
      // 2. format the formula
      for (k, v) in counts {
          // 2.1 omit number if the count is 1: C1H4 ==> CH4
          let mut s = String::new();
          if v > 1 {
              s = v.to_string();
          }
          // 2.2 special treatments for C and H
          let reduced = format!("{}{}", k, s);
          if *k == "C" {
              syms.insert(0, reduced);
          } else if *k == "H" {
              to_append = reduced;
          } else {
              syms.push(reduced);
          }
      }
      // 3. final output
      syms.push(to_append);
      let formula = syms.join("");
      formula
  }

  #[test]
  fn test_formula() {
      let symbols   = vec!["C", "H", "C", "H", "H", "H"];
      let formula = get_reduced_formula(&symbols);
      assert!(formula == "C2H4".to_string());
      let symbols   = vec!["C", "H", "C", "H", "H", "O", "H", "O"];
      let formula = get_reduced_formula(&symbols);
      println!("{:?}", formula);
      assert!(formula == "C2O2H4".to_string());
  }
#+end_src

*** parse file
从lammps data输入文件中读入结构信息.
格式参考: [[http://lammps.sandia.gov/doc/2001/data_format.html][LAMMPS Data Format]]

从文件名猜出其它需要的文件, 比如:
: V2O5_010_MeOH_rand_nvt_650_20.bonds => V2O5_010_MeOH_rand_nvt_650_20.data ==> V2O5_010_MeOH_rand_nvt_650_20.dump

读取lammps的data文件. 读入信息包括:
1. 总原子数.
2. 总原子类型数.
3. 原子数型编号与元素的对应关系.
4. 体系中所有的原子, 元素, 坐标等.

#+name: 1f4bb42e-6c9c-41d1-b9f3-e0908813187a
#+begin_src rust
  fn parse_lammps_data_file(file: File) -> Result<String, io::Error>{
      let mut reader = BufReader::new(file);
      let mut lines_iter = reader.lines();

      // skip the first two lines
      for _ in 0..2 {
          lines_iter.next();
      }
      // 1. read number of total atoms
      // 684  atoms
      let mut natoms = 0;
      let nresult = lines_iter.next();
      println!("{:?}", nresult);
      if let Some(line) = nresult {
          // pick out plain string, propagate IO error if any
          let line = line?;
          assert!(line.contains(" atoms"), format!("cannot find number of atoms: {}", line));
          let v: Vec<_> = line.split_whitespace().collect();
          natoms = v[0].parse().unwrap();
      } else {
          eprintln!("{:?}", nresult);
      }

      // 2. read in number of atom types
      let mut natom_types = 0_usize;
      loop {
          if let Some(line) = lines_iter.next() {
              let line = line?;
              println!("{:?}", line);
              if line.ends_with("atom types") {
                  if let Some(n) = line.split_whitespace().nth(0) {
                      natom_types = n.parse().unwrap();
                  }
                  break;
              }
          } else {
              panic!("cannot find atom types lines in lammps data file");
          }
      }

      // 3. parse atom types
      // 3.0 jump to Masses section
      loop {
          if let Some(line) = lines_iter.next() {
              let line = line?;
              if line.starts_with("Masses") {
                  break;
              }
          }
      }
      // 3.1 read in atom type maping
      // NOTE: element symbol is supposed to be after `#`
      //     1  50.941500   # V
      // skip one blank line
      assert!(natom_types > 0);
      lines_iter.next();

      // mapping: atom_index ==> atom_symbol
      let mut mapping_symbols = HashMap::new();
      for _ in 0..natom_types {
          if let Some(line) = lines_iter.next() {
              let line = line.unwrap();
              let mut attrs = line.split_whitespace();
              let k = attrs.nth(0).unwrap();
              let v = attrs.last().unwrap();
              mapping_symbols.insert(k.to_string(), v.to_string());
          }
      }
      println!("{:?}", mapping_symbols);

      // 3. jump to Atom section
      loop {
          if let Some(line) = lines_iter.next() {
              let line = line?;
              if line.starts_with("Atom") {
                  break;
              }
          } else {
              panic!("cannot find Atom lines in lammps data file");
          }
      }
      // skip one blank line
      lines_iter.next();
      // 4. read in atom index and atom type
      assert!(natoms > 0);
      for _ in 0..natoms {
          if let Some(line) = lines_iter.next() {
              let line = line?;
              // println!("{}", line);
          } else {
              panic!("Atom records are incomplete.");
          }
      }

      Ok("G".to_string())
  }

  fn open_file(filename: &str) -> Result<String, io::Error> {
      // 1. guess required lammps files from input filename
      let path = Path::new(filename);
      let path_lammps_data = path.with_extension("data");
      let path_lammps_bonds = path.with_extension("bonds");
      let path_lammps_dump = path.with_extension("dump");

      // assert!(path_lammps_data.is_file());
      // assert!(path_lammps_bonds.is_file());

      // Open the path in read-only mode, returns `io::Result<File>`
      let f = File::open(path_lammps_data)?;
      parse_lammps_data_file(f);

      Ok("Good".to_string())
  }

  #[test]
  fn test_open_file() {
      let path = "/home/ybyygu/Workspace/Projects/structure-prediction/data/e2/789648-d084-401b-a67e-e9628a29ca12/测试文件/V2O5_010_MeOH_rand_nvt_650_20.bonds";
      let fp = open_file(path);
  }

#+end_src

*** graph operation
#+name: 84783441-0f98-4bd5-87a2-44b54dac4b22
#+begin_src rust
  fn get_edge_from_line(line: String) -> (String, String, Vec<(String, String)>) {
      //  301 4 3 289 308 307 0         1.129         1.232         1.231         3.591         0.083         0.362
      let line = &*line;
      let mut bonds = Vec::new();
      let mut attrs = line.split_whitespace();
      // 1. get the first item

      let current = attrs.nth(0).unwrap();
      let nsymbol = attrs.next().unwrap();

      if let Some(nb) = attrs.next() {
          let nb = nb.parse::<u32>().unwrap();
          for _ in 0..nb {
              let other = attrs.next().unwrap();
              bonds.push((current.to_string(), other.to_string()))
          }
      }
      (current.to_string(), nsymbol.to_string(), bonds)
  }

  // print all connected components
  fn show_fragments(graph: &UnGraph<&str, i32>) {
      let sccs = pg::algo::kosaraju_scc(&graph);
      let mut symbols = vec![];
      for x in sccs {
          symbols.clear();
          for index in x {
              let t = graph[index];
              match t {
                  "1" => symbols.push("C"),
                  "2" => symbols.push("H"),
                  "3" => symbols.push("O"),
                  "4" => symbols.push("N"),
                  _   => println!("special case: {}", t),
              }
              let formula = get_reduced_formula(&symbols);
              println!("{:?}", formula);
          }
      }
  }

  /// read data from file
  fn read_from_file(filename: &str){
      // Create a path to the desired file
      let path = Path::new(filename);
      let display = path.display();

      // Open the path in read-only mode, returns `io::Result<File>`
      let f = match File::open(filename){
          // The `description` method of `io::Error` returns a string that
          // describes the error
          Err(why) => panic!("Couldn't open file {}: {}", display, why.description()),
          Ok(file) => file,
      };

      let mut reader = BufReader::new(f);
      let mut lines_iter = reader.lines().map(|l| l.unwrap());
      let mut timestep = 0 as u32;
      let mut natoms = 0 as u32;
      // representing molecule
      // let mut G = Graph::new_undirected();

      let lbl_timestep = "# Timestep";
      let lbl_natoms   = "# Number of particles";
      'outer: loop {
          // 1. jump to the line containing Timestep
          match lines_iter.nth(0) {
              Some(line) => {
                  assert!(line.starts_with(lbl_timestep), line);
                  let x = line.chars().as_str().replace(&lbl_timestep, "");
                  timestep = x.trim().parse::<u32>().unwrap();
                  println!("current timestep: {}", timestep);
              },
              None => {
                  break;
              }
          }
          // 2. read in number of atoms
          let line = lines_iter.nth(1).unwrap();
          assert!(line.starts_with(lbl_natoms), line);
          // only necessary for the first time
          if natoms == 0 {
              let x = line.chars().as_str().replace(&lbl_natoms, "");
              natoms = x.trim().parse::<u32>().unwrap();
              println!("number of atoms: {:?}", natoms);
          }
          // 3. read in following 4 commenting lines
          for _ in 0..4 {
              if let Some(line) = lines_iter.next() {
                  println!("{}", line);
              } else {
                  break; // fail
              }
          }
          // 4. read in bonds lines for each atom
          // construct graph structure
          // let mut node_indices = HashMap::new();
          // for x in 1..(natoms+1) {
          //     let n = G.add_node("X");
          //     node_indices.insert(format!("{}", x), n);
          // }
          // 5. parse current snapshot
          let mut data = vec![];
          for i in 0..natoms {
              match lines_iter.next(){
                  Some(line) => {
                      data.push(line);
                  },
                  None => {
                      panic!("file seems not complete: expected {} lines, acutaully read {:?} lines.", natoms, i)
                  }
              }
          }
          let mut G = Graph::new_undirected();
          let mut node_indices = HashMap::new();
          for line in &data {
              // let n = G.add_node(nsymbol);
              let line = &*line;
              let mut attrs = line.split_whitespace();
              let current = attrs.next().unwrap();
              let nsymbol = attrs.next().unwrap();
              let n = G.add_node(nsymbol);
              node_indices.insert(current, n);
          }
          // add bonds
          for line in &data {
              let line = &*line;
              let mut attrs = line.split_whitespace();
              let current = attrs.next().unwrap();
              attrs.next();
              if let Some(nb) = attrs.next() {
                  let nb = nb.parse::<u32>().unwrap();
                  for _ in 0..nb {
                      let other = attrs.next().unwrap();
                      let n1 = node_indices.get(&current).unwrap();
                      let n2 = node_indices.get(&other).unwrap();
                      G.update_edge(*n1, *n2, 1);
                  }
              }
          }
          show_fragments(&G);
          // skip one line
          // line = "#"
          lines_iter.next();
      }
  }

#+end_src

*** main
#+name: b8ea57f0-b549-4fa0-ac1a-abf83009009e
#+BEGIN_SRC rust
  /// get file name from command line argument
  fn get_filename() -> Result<String, String> {
      use clap::{App, Arg, AppSettings};

      let app = App::new("myapp");

      let matches = App::new("MyApp")
          .version("0.1")
          .author("Wenping Guo <winpng@gmail.com>")
          .about("reaction analysis")
          .arg(
              Arg::with_name("debug")
                  .help("debug switch")
                  .long("debug")
                  .multiple(true)
                  .short("d")
          )
          .arg(
              Arg::with_name("input")
                  .help("set input file name")
                  .index(1)
          )
          .setting(AppSettings::ArgRequiredElseHelp)
          .get_matches();
      let r = matches.value_of("input");
      match r {
          Some(v) => Ok(v.to_string()),
          None => Err("bad".to_string())
      }
  }

  fn main() {
      let filename = get_filename().unwrap();
      // read_from_file(filename.as_str());
      let r = open_file(filename.as_str());
      println!("{:?}", r);
  }
#+END_SRC

* src
** cmdline
:PROPERTIES:
:header-args: :tangle src/cmdline/main.rs
:END:

#+name: d0e077ec-1065-4135-a81d-db3d27ffd37e
#+begin_src rust
  extern crate clap;

  use std::env;
  use clap::{App, Arg};
  use std::io;
  use std::io::prelude::*;
  use std::fs::File;
  use std::io::BufReader;
  use std::cmp::Eq;


  #[derive (Default, Debug, PartialEq, PartialOrd, Clone)]
  /// Point3D, a point / position within 3D space
  pub struct Point3D {
      pub x: f64,
      pub y: f64,
      pub z: f64
  }

  impl Point3D {
      pub fn new(x: f64, y: f64, z: f64) -> Self {
          Point3D {x: x, y: y, z: z}
      }
  }

  impl Eq for Point3D {}

  #[test]
  fn point_3d_test() {
      let p = Point3D::new(0., 0., 0.);
      assert!(p.x == 0.);
      assert!(p.y == 0.);
      assert!(p.z == 0.);

      let p2 = Point3D::new(0., 0., 0.);
      assert!(p == p2);
  }


  fn readfile(filename: &str){
      let mut f = File::open(filename).expect("cannot open file");
      let reader = BufReader::new(f);
  }

  fn main() {
      // let args: Vec<String> = env::args().collect();
      // println!("{:?}", args);
      // println!("{:?}", args.len());
      let matches = App::new("MyApp")
          .version("0.1")
          .author("Wenping Guo <winpng@gmail.com>")
          .about("Does awesome things")
          .arg(
              Arg::with_name("debug")
                  .help("debug switch")
                  .long("debug")
                  .multiple(true)
                  .short("d")
          )
          .arg(
              Arg::with_name("input")
                  .help("set input file name")
                  .index(1)
          )
          .get_matches();

      match matches.occurrences_of("debug") {
          0 => println!("Debug mode is off"),
          1 => println!("Debug mode is kind of on"),
          2 => println!("Debug mode is on"),
          3 | _ => println!("Don't be crazy"),
      }

      if let Some(o) = matches.value_of("input") {
          println!("Value for input: {}", o);
          readfile(o);
      }
  }
#+end_src

** main
:PROPERTIES:
:header-args: :tangle src/main.rs
:END:
*** globals
#+name: f8c09544-ff6f-4589-9c06-d83d9b36e3ab
#+begin_src rust
  // extern crate base64;
  #[macro_use]
  extern crate nom;
  extern crate petgraph;
#+end_src

*** basis
#+name: b08803c2-e9b1-4542-9574-b8c467d527b1
#+BEGIN_SRC rust
  fn sqrt(x: f64) -> f64 {
      let mut y:f64 = if x < 5. {5.} else {10.};
      loop {
          y += 1.;
          if y > 15. {
              break;
          }
      }
      y.sqrt()
  }

  fn test_tuple() -> (i32, i32){
      let t = (1, 2);
      let (a, b) = t;
      let i = 1;
      t
  }

  fn test_array() {
      let arr: [f64; 100] = [0.1; 100];
      println!("{:?}, {}", arr[10], arr.len());

      let mut arr = [1, 5, 3, 2];
      arr.sort();
      println!("{:?}", arr);
  }

  fn test_vector() {
      let mut v = vec![1, 2, 0, 5];
      v.insert(0, 13);
      assert_eq!(v, [13, 1, 2, 0, 5]);
      assert_eq!(v[0], 13);
      let v:Vec<i32> = (0..5).collect();
      println!("{:?}", v);
  }

  fn test_slice() -> i32 {
      let arr = [1, 2, 3, 4];
      let slice = &arr;
      let last = slice.get(3);
      println!("last = {}", last.unwrap());
      // println!("last = {}", arr[5]);
      ,*last.unwrap()
  }

  fn test_string () {
      // let mut s = "good to go to do".to_string();
      // s.push('好');
      // let x = s.pop();
      // println!("x={:?}, s={:?}", x.unwrap(), s);
      // println!("{}", "y̆".len());
      // println!("{:?}", "y̆".chars());
      let mut s = "good";
      println!("{:?}", s);
  }

  fn test_hashmap() {
      use std::collections::HashMap;
      let mut scores = HashMap::new();
      scores.insert("Blue", 10);
      // scores.insert("Blue", 20.); adding float will fail
      println!("{:?}", scores);
  }

#+END_SRC

*** nom
#+name: 76f3c475-acd4-492d-b4fc-50da7265bfd9
#+begin_src rust
  fn test_nom(){
      named!(get_greeting<&str,&str>,
             take_s!(2)
      );

      let res = get_greeting("hi there");
      println!("{:?}",res);
  }
#+end_src

*** atoms
定义最简单的原子结构信息.
#+name: 1f84ef01-7ddb-4295-8521-c29ad7d7e059
#+begin_src rust
  use std::hash::{Hash, Hasher};
  use std::cmp::Ordering;

  #[derive (Default, Debug, Clone, Copy)]
  /// simple atom data structure
  pub struct Atom {
      pub index: u64,
      pub symbol: &'static str,
  }

  impl PartialEq for Atom {
      fn eq(&self, other: &Atom) -> bool {
          self.index == other.index
      }
  }

  impl Eq for Atom {}

  impl Hash for Atom {
      fn hash<H: Hasher>(&self, state: &mut H) {
          self.index.hash(state);
      }
  }

  impl Ord for Atom {
      fn cmp(&self, other: &Atom) -> Ordering {
          self.index.cmp(&other.index)
      }
  }

  impl PartialOrd for Atom {
      fn partial_cmp(&self, other: &Atom) -> Option<Ordering> {
          Some(self.cmp(other))
      }
  }

  #[test]
  fn test_atom() {
      let a = Atom{
          index: 1,
          symbol: "H",
      };

      let b = Atom {
          index: 2,
          symbol: "H",

      };
      let mut c = Atom {
          index: 1,
          symbol: "H",
      };

      assert!(a != b);
      assert!(a == c);

      assert!(a.index == 1);
      assert!(a.symbol == "H");

      c.symbol = "C";
      assert!(c.symbol == "C");
  }
#+end_src

实现从元素符号列表到分子式.
#+name: 27fa4abe-d98c-4dd4-8695-e4b4f807cabc
#+begin_src rust
  use std::collections::HashMap;

  // fn get_reduced_formula<'a, I>(symbols: I) -> Option<&'static str>
  //     where I: Iterator<Item=&'static str>,
  // {
  //     for x in symbols {
  //         println!("{:?}", x);
  //     }

  //     Some("C2H4")
  // }

  fn get_reduced_formula(symbols: &[&str]) -> String {
      let mut counts = HashMap::new();
      for x in symbols {
          let c = counts.entry(x).or_insert(0);
          ,*c += 1;
      }

      let mut syms: Vec<String> = Vec::new();
      let mut to_append = String::new();

      for (k, v) in counts {
          let reduced = format!("{}{}", k, v);
          if *k == "C" {
              syms.insert(0, reduced);
          } else if *k == "H" {
              to_append = reduced;
          } else {
              syms.push(reduced);
          }
      }
      syms.push(to_append);
      let formula = syms.join("");
      formula
  }

  #[test]
  fn test_formula() {
      let symbols   = vec!["C", "H", "C", "H", "H", "H"];
      let formula = get_reduced_formula(&symbols);
      assert!(formula == "C2H4".to_string());
      let symbols   = vec!["C", "H", "C", "H", "H", "O", "H", "O"];
      let formula = get_reduced_formula(&symbols);
      println!("{:?}", formula);
      assert!(formula == "C2O2H4".to_string());
  }
#+end_src

*** petgraph
#+name: deb8ea39-2a90-4db1-987b-121d98047d53
#+begin_src rust
  fn test_petgraph() {
      use petgraph as pg;
      use std::collections::HashMap;

      let mut G = pg::Graph::new_undirected();
      let aa = [0; 4];
      let bb = [1; 4];
      let x = G.add_node(aa);
      let y = G.add_node(bb);
      let e = G.add_edge(x, y, (1, 1));
      let f = G.add_edge(x, y, (2, 2));
      println!("{:?}", &G[x]);
      println!("{:?}", &G[y]);
      println!("{:?}", e);
      println!("{:?}", &G[e]);
      println!("{:?}", f);
      println!("{:?}", &G[f]);
  }

  fn test_petgraph_graphmap() {
      use petgraph as pg;
      use petgraph::prelude::*;
      let mut G = UnGraphMap::new();

      let a = Atom{
          index: 1,
          symbol: "H",
      };

      let b = Atom{
          index:2,
          symbol:"H",
      };

      println!("{:?}, {:?}", a, b);
      G.add_node(a);
      G.add_node(b);
      G.add_edge(a, b, 1);
      println!("{:?}", &G);
      println!("{:?}", &G[(a, b)]);
  }
#+end_src

*** cmdline
#+name: 82c97bbd-b1b7-492e-8aa2-31271b45b049
#+begin_src rust
  fn main() {
      // let bytes = base64::decode("aGVsbG8gd29ybGQ=").unwrap();
      // println!("{:?}", bytes);

      // println!("this is a hello {}", "world");
      // println!("{}", 12);

      // let mut sum = 0.;
      // for i in 0..5 {
      //     sum += i as f64;
      //     println!("loop: {}, sum = {}", i, sum);
      // }

      // let mut v = sqrt(sum);
      // println!("{}", v);

      test_petgraph_graphmap();
  }
#+end_src

* References
- [[https://rust-lang-nursery.github.io/rust-cookbook/basics.html][Rust Cookbook]]
- [[http://stevedonovan.github.io/rust-gentle-intro/readme.html][Introduction - A Gentle Introduction to Rust]]
- [[https://rustbyexample.com/][Introduction - Rust By Example]]
- [[https://learnxinyminutes.com/docs/rust/][Learn rust in Y Minutes]]

* Local variables
# Local Variables:
# mode: org
# end:

#+TITLE: Learn Rust: hack without fear!
#+SETUPFILE: ~/Notes/common.org
#+SETUPFILE: ~/Notes/latex.org
#+SETUPFILE: ~/Notes/coding.org

* Memo [2/10]
** [2018-02-19 Mon] rust升级至1.24, 新功能: 增量编译. 调代码效率可以高一些了.
** [2018-02-19 Mon] cgmath基本用法
: np.linalg.norm => vector.magnitude()
: mat.T => mat.transpose()
: np.linalg.inv(mat) => mat.invert()

** [2018-02-18 Sun] 使approx crate来测试浮点数值的匹配性
#+name: c388cfa1-83ec-4833-af78-b3a6698def26
#+begin_src rust
  #[macro_use]
  extern crate approx;

  assert_relative_eq!(expected, actual, epsilon=1e-4);
#+end_src

** [2018-02-18 Sun] Rust中的浮点数没有实现全序, 不能使用max, min函数
: [0.0, xy, xz, xy+xz].iter().fold(f64::MIN, |a, &b| a.max(b));

** DONE [2018-02-17 Sat] ovito输出至POSCAR后 原子次序会重排. 需要结构提取功能.
CLOSED: [2018-02-20 Tue 20:09]
- State "DONE"       from "TODO"       [2018-02-20 Tue 20:09]
需要写一个能输出CIF文件的程序. 保留原子次序和键连关系.

- [X] 周期性镜像原子间的成键问题.

** [2018-02-16 Fri] iterator.peek的用法
很容易报错:
: cannot move out of borrowed content

正确的写法:
#+name: 3be15f32-d8d6-4da9-be88-d0076cf849cb
#+begin_src rust
  lines_iter = fp.lines().peekable();
  if let Some(&Ok(ref firstline)) = lines_iter.peek() {
      if ! firstline.starts_with("LAMMPS data file") {
      }
      ...
  }
#+end_src

** TODO [2018-02-13 Tue] rust测试工具
测试分为集成测试和单元测试. 单元测试是开发者站在内部的角度来写, 测试代码和功能代
码放在一起, 可以自由访问任意变量和函数. 集成测试是站在外部使用者的角度来写的, 测
试代码放在和src目录同级的tests目录下, 目的是测试整个程序的集成效果.

代码标注:
: #[test]
或
: #[test]
: #[ignore]
这样测试里会忽略.

测试:
: cargo test

可以将test代码放到mod里, 以#[cfg(test)]标注, 这样可以减少最终执行文件的大小.

集成测试中的代码适合放练手代码, 不需要写主程序, 不会被编入其它主程序中. 用cargo
很容易调用:
: cargo test -- --nocapture

** TODO [2018-02-04 Sun] 快被String, str, &str, "str"之间的区别搞死了
- literal string是静态分配的常量, 和整型, 浮点数一样的语义.
- String是动态分配的, 可变的字符串. self-owned. 函数定义时, 优先用这个, 省掉不少
  麻烦.
- &String是对String的只读引用.
- &str是string slice.

** [2018-02-04 Sun] rust现在还不支持函数中使用默认参数 [[https://users.rust-lang.org/t/default-values-for-function-parameters/12483/3][URL]]
** DONE [2018-02-03 Sat] 如何写一个能接受Iterator类型的函数
CLOSED: [2018-02-13 Tue 12:34]
- State "DONE"       from "TODO"       [2018-02-13 Tue 12:34]
- [[https://stackoverflow.com/questions/43057946/how-do-i-write-a-function-in-rust-that-accepts-any-iterator-whose-item-fulfills][How do I write a function in Rust that accepts any iterator whose Item fulfills a trait?]]

#+name: 05a53a8c-ff59-4a92-8181-e97a028f9545
#+begin_src rust
  fn parse_lammps_bonds_single_snapshot<I>(lines_iter: &mut I) -> Result<String, String>
      where I: Iterator<Item=io::Result<String>>
  {
      ;
  }
#+end_src

** TODO [2018-02-02 Fri] 错误处理
- [[https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-][A Shortcut for Propagating Errors: ?]]

函数返回类型:
: -> Result<(), Box(Error)>

** [2018-02-01 Thu] Eq与PartialEq
- [[https://doc.rust-lang.org/std/cmp/trait.PartialEq.html][std::cmp::PartialEq - Rust]]
- [[https://doc.rust-lang.org/std/cmp/trait.Eq.html][std::cmp::Eq - Rust]]
- [[https://doc.servo.org/core/cmp/trait.Ord.html][core::cmp::Ord - Rust]]

Eq是PartialEq的加强版.

PartialEq不要求自相等. 比如: a可以不等a(以浮点数为例).

** [2018-01-31 Wed] 使用petgraph来操作图论结构 [[https://github.com/bluss/petgraph][petgraph]]
第一印象: 没有networkx的api那么方便.

求connected_components用petgraph::algo::kosaraju_scc即可.

有三种graph类型.

*** Graph
: let node_index = G.add_node(weight);
这和networkx的语法不同, add_node的参数是weight, 不是node数据. 返回值为node_index.

: let edge_index = G.add_edge(n1, n2, edage_data);
n1, n2为node_indices, edage_data可为任意数据类型. 返回值为edge_index

: let node_weight = &G[node_index];
: let edge_weight = &G[edge_index];
有了indices, 可以方便地访问graph节点和边关联的数据.

add_edge时需注意:默认petgraph充许parallel edges, 因此多次添加edge时, 会生成两个
节点间的多个边. 使用update_edge函数可避免这个问题.
*** GraphMap
这个更接近于networkx中的Graph对象的实现方式. 基于petgraph作者写的[[https://github.com/bluss/ordermap][ordermap]] (后续
可能会换名字: IndexMap).

不充许parallel-edge(两个不同节点间有多条边), 但充许有self-loop(同一节点间形成的
边).

: G.add_node(n);
其kosaraju_scc中n用来指示不同的node. 不能设定node data, 或者说n本身就是data(结构体).

: G.add_edge(n1, n2, edge_data);
添加节点n1和n2之间的边.

*** StableGraph

** TODO [2018-01-28 Sun] 使用nom解析格式化文件
- [[https://stevedonovan.github.io/rust-gentle-intro/nom-intro.html#parsing-text-with-nom][Parsing with Nom - A Gentle Introduction to Rust]]
- [[http://rust.unhandledexpression.com/nom/][nom - Rust]]

nom的优点:
- 解析单元可自由组合 (parser combinator library)
- 容易调试, 容易集成. 方便实现更复杂的解析逻辑
- 比regex更快.

** [2018-01-19 Fri] 文件读写
- [[https://doc.rust-lang.org/std/fs/struct.File.html][std::fs::File - Rust]]
- [[https://doc.rust-lang.org/std/io/index.html][std::io - Rust]]
- [[https://doc.rust-lang.org/std/io/struct.BufReader.html][std::io::BufReader - Rust]]

*** reader.read_line
需要string参数. 将新读入的一行数据附加到buf中. 返回读入的字节数.

** [2018-01-18 Thu] Result和Option类型
Result枚举类型是对所有返回值的完全分类：正常（Ok）或出错（Err）。Option枚举类型
是对所有可选项的完全分类，有值（Some）或无值（None）。

Result和Option经常用于匹配参数返回不同数据上（match）。

Reference
- [[https://doc.rust-lang.org/std/result/][std::result - Rust]]
- [[https://doc.rust-lang.org/std/option/][std::option - Rust]]

** [2018-01-18 Thu] [[https://blog.rust-lang.org/2017/12/21/rust-in-2017.html][Rust in 2017: what we achieved]]
感觉上是python和C的完美结合.

- [[https://github.com/rust-lang-nursery/tempdir][rust-lang-nursery/tempdir: Temporary directory management for Rust]]
- [[https://github.com/rayon-rs/rayon][rayon-rs/rayon: Rayon: A data parallelism library for Rust]]

** TODO [2018-01-17 Wed] 使用log工具
- [[https://github.com/rust-lang-nursery/log][rust-lang-nursery/log: Logging implementation for Rust]]

log将和slog合并: [[https://github.com/rust-lang-nursery/log/issues/149][Structured Logging · Issue #149 · rust-lang-nursery/log]]

** [2018-01-17 Wed] rust基础练习4: 简单命令行界面
可以使用std::env来提取. env::args返回的是Iterator, 其中每个参数都为string类型.

复杂点的可以用[[https://github.com/kbknapp/clap-rs][clap]].

** [2018-01-01 Mon] rust ownership :ATTACH:
:PROPERTIES:
:ID:       dfcf2ff4-7214-483f-8b66-bf76a0372e8a
:Attachments: rust-intro-2018-01-01142409_2018-01-01_14-26-11.png
:END:

#+DOWNLOADED: @ 2018-01-01 14:26:11
#+attr_org: :width 600
#+attr_odt: :width 8
[[file:data/df/cf2ff4-7214-483f-8b66-bf76a0372e8a/rust-intro-2018-01-01142409_2018-01-01_14-26-11.png]]

** TODO [2017-12-30 Sat] 完成[[http://exercism.io/languages/rust/exercises][exercism.io]]上的练习
** TODO [2017-12-30 Sat] 使用rust来完成之前写的lindermann指数计算程序
** [2017-12-26 Tue] rust基础练习3 基本数据结构
*** tuple
: tuples like (1, true)
- tuple中的数据通常是不同类型的.
- 通过tuple, 函数可以返回多个数值.

tuple输出时:
: println("{:?}", (1, 2));

tuple可以通过位置来指认:
#+name: 7db31524-8474-431d-8e3c-279dd552c4e3
#+begin_src rust
  let t = (1, 2);

  print!("{}, {}", t.0, t.1);
#+end_src

可以像python一样, 可以把tuple展开给多个变量:
#+name: efd8cd2d-26a7-47da-a4ab-841a2f6a1396
#+begin_src rust
  let t = (1, 2, 3);
  let (a, b, c) = t;
#+end_src
注意左侧的变量要用tuple的形式括起来, 否则会报错. 这也python不同.

注意tuple引用内部成员时不能使用变量, 也不能像python的那样来取值. 下面的语句是错的:
: let t = (12, 2, 'a');
: let i = 1;
: println! ("{}", t.i);  // 错误
: println! ("{}", t[0]); // 错误

只有一个成员的tuple, 后面的逗号不能省略:
: let t = (12,);

无成员类型:
: let t = ();

函数无返回值时, 默认返回(), 相当于python中的None?

还有一点与python不同. 因为tuple中成员类型不同, 用于loop时没意义. 可以换array来更
好的实现相应的功能.

*** arrays, slices
: arrays like [1, 2, 3]
rust中的array和C里的静态数组类似, 成员类型要一致, 运行时不可增删.
#+name: 263760d4-6182-4794-8e27-704b2aa61a31
#+begin_src rust
  let arr = [1, 2, 5, 9, 10];
  println!("{}", arr[0], array[2]);
#+end_src
如何访问数组成员越界, rust在编译时就会报错.

成员函数:
: arr.len();
: arr.sort();

数组声明时, 要指明成员数值类型及成员数:
: let arr: [i32; 5] = [1, 2, 3, 4, 6];
注意中间用的是分号.
: let arr: [i32; 500] = [12; 500];
注意右侧的值为500个12.

如果要使用range来提取多个数值, 需要取址, 用slice:
: &arr[1..5]

二维数组:
#+name: ec1673bf-357a-475c-bb95-ff63fe463bc2
#+begin_src rust
  let arr = [[1, 5], [2, 4]];
  println!("{:?}", arr[0][1]);
#+end_src

slice在运行期才能知道数组的大小, 为了避免panic, 可以用slice.get方法
#+name: f9bd3ee7-0cce-4adc-a0da-cf3a440101b4
#+begin_src rust
  let arr = [1, 2, 3, 4];
  let slice = &arr;
  let last = slice.get(5);
#+end_src
这与python中的dict.get类似. slice访问如果越界, 会返回一个特殊的数据结构Option,
值为None.

Option对象可用函数:
: last.is_some();
: last.is_none();
如果opt有值, 可以提出来:
: last.unwrap();
如果opt是None, unwrap的话运行时会panic.

更便捷的方式是使用unwrap_or
: last.unwrap_or(&-1)
注意参数用&取址.

注意last.unwrap()取出的数据为reference, 不是实在的数据. 记得根据需求解引:
: *last.unwrap()
*** vector
vector是动态数组, 同array一样, 成员类型要一致.

声明变量:
: let v = vec![2, 3, 1, 5];
或者:
: let v = Vec::new();
: v.push(2);
: ...

可以从iterator初始化:
: let v:Vec<i32> = (0..5).collect();
注意v要指明类型.

添加元素:
: v.push(1);

插入元素:
: v.insert(1, 'a');

删除元素:
: v.remove(1);

*** string
**** char
单引号: char
双引号: literal string

**** str, string literal
双引号中的为literal string (&'static str). literal string为静态数据类型, 就像是
整型, 浮点型.

中间可以包括硬回车或转义字符.
#+name: c0f6ce7f-deac-4321-9c14-4312a9518957
#+begin_src rust
  let s = "good to go\n";

  let s = "good
  to go";

  // s = good togo
  let s = "good to\
           go";
#+end_src
字串中可以使用~\~来续行.

raw string:
#+name: 3de9f418-5b32-42b6-bf5c-6285b458ad7c
#+begin_src rust
  // s = "\n\n"
  let s = r"\n\n";
#+end_src

lieral string可用的函数:
: s.len();
与python不同, rust中的string不能index, 比如s[0], 但可以slice:
#+name: 7a55e292-1387-4cdc-8f05-14e9ed00c888
#+begin_src rust
  let s = "abcdef";
  let subs = &s[1..2]
#+end_src

对于多行文本, 可以直接使用lines函数来对行进行枚举操作.
: txt.lines()

**** String
内存动态分配的string.

[[https://doc.rust-lang.org/std/string/struct.String.html][std::string::String - Rust]]

A UTF-8 encoded, growable string

初始化:
: let s = String::new();
: let s = String::from("world");
: let s = "Hello".to_string();

修改字串:
string.push, string.push_str, string.pop, string.remove, string.insert, string.insert_str, string.truncate, string.clear
: s.push('1');
: s.push('好');
: s.push_str("bar");

可以像python一样, 使用"+"来合并字串:
#+name: 9e15f850-01c6-4368-b21e-fe560b347feb
#+begin_src rust
  let mut s = "good to go to do".to_string();
  s.push('d');
  println!("{}", s + "good");
#+end_src

使用format! macro来生成格式化字符串.
#+name: 21f9c2a1-d351-468e-a414-c37f018903df
#+begin_src rust
  let s = format!("{}", 2.2);
#+end_src

合并字串
#+name: 425fe069-3e10-417a-8929-2551b7417db2
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.concat();
#+end_src

像python中的str.join
#+name: f91f9154-1da8-4788-a969-dc72a2e281c1
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.join("\n");
#+end_src

取子串:
: s.chars()

其它:
contains, replace, trim, split

测试:
string.contains, string.starts_with, string.ends_with, string.find

其它:
string.split, string.trim, string.repeat
: assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));

iteration
string.chars

&string: shared reference to string
&str: string slice
*** TODO hash maps
- [[https://doc.rust-lang.org/book/second-edition/ch08-03-hash-maps.html][Hash Maps - Hash Maps - The Rust Programming Language]]

*** TODO structs
这个像namedtuple, C里的结构体. 通名称来指认内部成员更方便些.

** [2017-12-21 Thu] rust基础练习2 control flow
#+name: 5fde93b8-94a6-4341-9db8-f3625238dfc5
#+BEGIN_SRC rust
  if (a < b) {
      println!("{}", 1);
  } else {
      println!("{}", 2);
  }
#+END_SRC

如果是多个条件:
: else if

注意if等判断语句后跟bool类型. rust不会像python做隐式类型转换. 比如下面的语句会报错:
#+name: be800e54-711b-4393-aefb-811c41ba2b7a
#+begin_src rust
  let r = 1;
  if r {...};
#+end_src

也可以像python写成单行表达式
#+name: 632a594b-c4a8-48db-ab4d-f176d44954b2
#+BEGIN_SRC rust
  let y:f64 = if a < 4. {1.} else {2.}
#+END_SRC
此时要注意, else前后的返回值类型要一致, 否则会报错.

循环结构可以用loop, while, for. break/continue同样可用.

对于多层循环, rust中可以使用标签, 然后break到指定位置. 见[[https://rustbyexample.com/flow_control/loop/nested.html][doc]].

rust使用match来实现像C里的switch语句类似的功能.

** [2017-12-20 Wed] rust基础练习1 变量常量类型
常量定义:
: let sum = 0;

变量定义:
: let mut sum = 0;

上面的sum变量被定义为整型, 可以加和整型数据.

如果sum定义为浮点数:
: let mut sum = 0.;
: sum += 1;
自加和整型数1会报错. 需要对1进行显式的类型转换:
: sum += 1 as f64;
或者:
: sum += 1_f64;

如果是变量必须用"as f64"
: sum += i as f64;

rust对数值类型要求很严, 整数除以浮点数会报错
: 12/2.

整数除以整数会得到一个整数:
: 13/6
上面的值为2

常见的数值类型: i32, i64, u32, u64, f32, f64

rust避免做任何假设, 这倒是免掉了C里面的不少坑.


常见数值运算: [[https://doc.rust-lang.org/std/primitive.f64.html][docs]]
: x.abs()
: x.powf(2.)
: x.sqrt()

#+name: dac3cc9f-d575-49e3-a759-49a1f88224e8
#+BEGIN_SRC rust
  for i in 0..5 {
      println!("loop {}", i);
  }
#+END_SRC

loop变量不需要显式定义.

自定义函数:
#+BEGIN_EXAMPLE
fn sqrt(x: f64) -> f64 {
  return x*x;
}
#+END_EXAMPLE
函数返回值以最后一个语句为准, 因此return可以略去(同时去掉最后的分号).

** TODO [2017-12-12 Tue] 使用rust实现之前写的files-coder
- [[https://github.com/hyperium/mime/][hyperium/mime: MIMEs in Rust]]

** [2017-12-10 Sun] 使用cargo来管理rust程序
: cargo new test1 --bin

: cargo run
快速语法检查:
: cargo check

测试:
: cargo test
测试时允许print语句输出:
: cargo test -- --nocapture

* cargo
#+name: 7935cdce-84b1-4d22-a63d-7d0a8580a279
#+BEGIN_SRC conf :tangle Cargo.toml
  [package]
  name = "test1"
  version = "0.1.0"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  base64 = "*"
  clap = "*"
  zip = "*"
  nom = "*"
  petgraph = "*"

#+END_SRC

* tests [0/0]
** scratch
#+name: 26fc6fdf-a306-4357-aa27-ceeb00164a2d
#+begin_src shell :results output
  cargo run
#+end_src

** hamming distance
*** test
#+name: 18144448-0970-4f66-bbd3-f206635ba2cf
#+begin_src shell :results output
  cd exercism/rust/hamming
  cargo test -- --nocapture
#+end_src

#+RESULTS: 18144448-0970-4f66-bbd3-f206635ba2cf
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 7 tests
test test_first_string_is_longer ... ok
test test_complete_hamming_distance_in_small_strand ... ok
test test_larger_distance ... ok
test test_no_difference_between_empty_strands ... ok
test test_no_difference_between_identical_strands ... ok
test test_second_string_is_longer ... ok
test test_small_hamming_distance_in_the_middle_somewhere ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/hamming/src/lib.rs
:END:

#+name: 86e0273f-d292-4c9a-a644-a82b07625639
#+begin_src rust
  pub fn hamming_distance(s1: &str, s2: &str) -> Result <usize, String> {
      if s1.len() != s2.len() {
          return Err("err".to_string())
      } else {
          let l = get_hamming_distance(s1, s2);
          Ok(l)
      }
  }

  fn get_hamming_distance(s1: &str, s2: &str) -> usize {
      assert_eq!(s1.len(), s2.len());

      let mut sum = 0;
      for (c1, c2) in s1.chars().zip(s2.chars()) {
          if c1 != c2 {
              sum += 1;
          }
      }
      sum
  }
#+end_src

** reverse string
*** test
#+name: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_src shell :results output
  cd exercism/rust/reverse*
  cargo test
#+end_src

#+RESULTS: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 5 tests
test test_a_capitalized_word ... ignored
test test_a_palindrome ... ignored
test test_a_sentence_with_punctuation ... ignored
test test_a_word ... ignored
test test_empty_string ... ok

test result: ok. 1 passed; 0 failed; 4 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/reverse-string/src/lib.rs
:END:

#+name: 3d017385-a2ca-49af-8494-9b2dd4569f24
#+begin_src rust
  pub fn reverse(s: &str) -> String {
      s.chars().rev().collect::<String>()
  }
#+end_src
* reaxa
一个小程序: 将.bonds转换为只保留键连信息的新文件, 以减少原.bonds文件的大小(可删).
** cargo
#+name: 5d1bf924-1dc8-44e9-9aad-f5bd83176c31
#+BEGIN_SRC conf :tangle reaxa/Cargo.toml
  [package]
  name = "reaxa"
  version = "0.1.0"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  clap = "*"
#+END_SRC

** src
:PROPERTIES:
:header-args: :tangle reaxa/src/main.rs
:END:

*** globals
#+name: 68b8f3aa-b3f8-43c0-8b4d-c3165b146535
#+begin_src rust
  extern crate clap;

  use std::fs::File;
  use std::error::Error;
  use std::io::{self, BufReader, BufWriter};
  use std::io::prelude::*;
  use std::collections::HashMap;
  use std::path::Path;

#+end_src
*** structs
#+name: 4cee223f-3139-4cec-a256-ce019e71ec9b
#+begin_src rust
  #[derive(Debug, Default, Clone)]
  struct AtomData{
      index: usize,
      symbol: String,
      neighbors: Vec<usize>,
      charge: f64,
  }
#+end_src

*** functions
**** outline
create a terse version of .bonds file

文件名 ==> 数据流 ==> 数据行

简略输出bonds文件中最重要信息
#+name: 385637c4-7071-4dbb-bf46-c65aef0f3774
#+begin_src rust
  fn write_terse_bonds_file_from() {
      ;
  }
#+end_src

**** on file basis
处理文件级别的逻辑
#+name: 92cd338c-f795-482a-b1de-6706e8f20058
#+begin_src rust
  /// Parameters
  /// ----------
  /// inputfile: a string pointing to the path of a .bonds file
  /// outputfile: a string pointing to the path of the output file
  fn create_terse_copy_of_lammps_bonds_file(inputfile: &str, outputfile: &str) -> Result<String, io::Error>
  {
      // 1.0 prepare input file stream
      let fp = File::open(inputfile)?;
      let mut reader = BufReader::new(fp);
      let mut lines_iter = reader.lines().peekable();

      // 1.1 prepare output file stream
      let path = Path::new(outputfile);
      if path.exists() {
          panic!("output file already exists: {}", outputfile);
      }

      let mut fp = File::create(path)?;
      let mut writer = BufWriter::new(&fp);

      // 2 create a terse copy for each frame
      // loop over frames in trajectory file
      loop {
          if lines_iter.peek().is_none() {
              println!("reached the end of the file.");
              break;
          }

          let output = parse_lammps_bonds_single_snapshot(&mut lines_iter).unwrap();
          writer.write_all(&output.as_bytes());
          if let Some(line) = lines_iter.next() {
              ;
          } else {
              println!("Warning: missing final blank comment.");
              break;
          }
      }

      Ok("done".to_string())
  }

  // #[test]
  // fn test_create_terse_copy() {
  //     let inputfile = "/home/ybyygu/Incoming/FeC reaxff tests/FeCO/f00000.bonds";
  //     let outputfile = "/home/ybyygu/Incoming/FeC reaxff tests/FeCO/test.bonds";
  //     create_terse_copy_of_lammps_bonds_file(inputfile, outputfile).unwrap();
  // }

#+end_src

**** on frame basis
处理轨迹中单一帧

#+name: 77ed312f-a109-44e6-bbe2-c72b3d2761a2
#+begin_src rust
  use std::iter::Peekable;

  fn parse_lammps_bonds_single_snapshot<I>(lines_iter: &mut I) -> Result<String, String>
      where I: Iterator<Item=io::Result<String>>,
  {
      let mut timestep = 0 as usize;
      let mut natoms = 0 as usize;

      let mut output:Vec<String> = Vec::new();

      // 1. read in meta data from comments
      // expected => Some(Ok("# Timestep 0 "))
      for n in 0..7 {
          let line = lines_iter.next().unwrap().unwrap();
          assert!(line.starts_with("# "), line);
          match n {
              0 => {
                  timestep = get_int_data_from_comment_line(&line, "# Timestep").unwrap();
                  output.push(line);
              },
              2 => {
                  natoms = get_int_data_from_comment_line(&line, "# Number of particles").unwrap();
                  output.push(line);
              },
              _ => (),
          }
      }

      println!("processing timestep {:} ...", timestep);
      let mut data = Vec::new();
      // 2. read atom data
      for _ in 0..natoms {
          if let Some(line) = lines_iter.next() {
              let line = line.unwrap();
              let x = get_terse_line_from_bonds_data_line(&line).unwrap();
              data.push(x);
          } else {
              let msg = format!("atom data is incomplete\ntimestep = {}", timestep);
              return Err(msg);
          }
      }

      // 3. append to output
      // atom indices are sorted in ascending order
      data.sort();
      for (_, s) in data {
          output.push(s);
      }

      Ok(output.join("\n") + "\n")
  }

  // #[test]
  // fn test_snapshot_parse() {
  //     let filename = "/home/ybyygu/Incoming/FeC reaxff tests/FeCO/Fe100_8816_50CO_500_500K.bonds";

  //     let f = File::open(filename).unwrap();
  //     let mut reader = BufReader::new(f);
  //     let mut lines_iter = reader.lines().peekable();

  //     let output = parse_lammps_bonds_single_snapshot(&mut lines_iter).unwrap();
  //     let path = Path::new("tt");
  //     let mut file = File::create(&path).unwrap();
  //     file.write_all(output.as_bytes());
  // }


#+end_src
**** on line basis
处理具体某行数据
***** 缩略输出
****** 有陨版: 保留连接表, 不保留bond order
#+name: db66fa83-96a3-4315-a379-d4a404ce076f
#+begin_src rust
  fn get_terse_line_from_bonds_data_line(line: &str) -> Result<(usize, String), String>{
      if line.starts_with("# ") {
          let msg = format!("incorrect line: {}", line);
          return Err(msg);
      }

      let mut attrs:Vec<&str> = line.split_whitespace().collect();
      let cur = attrs[0].parse::<usize>().unwrap();
      let nbonds = attrs[2].parse::<usize>().unwrap();
      let neighbors = &attrs[3..3+nbonds];

      // partial charge
      let charge = &attrs.last().unwrap();

      // using a string to store the result
      let mut result = format!("{}", charge);

      // 1. keep the neighbor which is larger than current
      // 2. store the shift relative to current
      for n in neighbors {
          let n:usize = n.parse().unwrap();
          if n > cur {
              result.push_str(format!(" {}", n - cur).as_str());
          }
      }

      Ok((cur, result))
  }

  #[test]
  fn test_terse_line() {
      // test1
      let s = " 1108 3 1 1107 0 1.479 1.479 2.000 -0.313";
      let new = get_terse_line_from_bonds_data_line(&s);
      assert!(new.is_ok());
      let (cur, result) = new.unwrap();
      assert!(cur == 1108);
      assert!(result.starts_with("-0.313"));

      // test2
      let s = " 137 1 9 9 249 257 138 145 153 265 273 129 0 0.450 0.450 0.710 0.410 0.709 0.450 0.450 0.709 0.709 5.047 -1.000 0.025";
      let new = get_terse_line_from_bonds_data_line(&s);
      assert!(new.is_ok());
      let (cur, result) = new.unwrap();
      assert!(cur == 137);
      assert_eq!(result, "0.025 112 120 1 8 16 128 136");
  }

#+end_src

****** 无陨版: 保留全部重要信息
#+name: b8a4e582-82ae-4acf-a8dd-5cad292095e1
#+begin_src rust :tangle no
  fn get_terse_line_from_bonds_data_line(line: &str) {
      ;
  }

  #[test]
  fn test_terse_line_v0() {
      // test1
      let s = " 1108 3 1 1107 0 1.479 1.479 2.000 -0.313";

      let new = get_terse_version_from_bonds_data_line(&s);

      // test2
      let s = " 137 1 9 9 249 257 138 145 153 265 273 129 0 0.450 0.450 0.710 0.410 0.709 0.450 0.450 0.709 0.709 5.047 -1.000 0.025";
      let new = get_terse_version_from_bonds_data_line(&s);
  }
#+end_src

***** 方便提取注释行中的数据, 比如总原子数等.
#+name: fbba88ec-5783-4732-a707-55322c79439f
#+begin_src rust
  fn get_int_data_from_comment_line(line: &str, prefix: &str) -> Result<usize, String> {
      if line.starts_with(prefix) {
          let s = line[prefix.len()..].trim().parse::<usize>();
          match s {
              Ok(v) => return Ok(v),
              Err(why) => return Err(format!("{:?}", why)),
          }
      } else {
          let msg = format!("Failed to get value {} for current frame: {}", prefix, line);
          Err(msg)
      }
  }

  #[test]
  fn test_get_int_data_from_comment_line() {
      // get timestep
      let r = get_int_data_from_comment_line("# Timestep 10", "# Timestep");
      assert_eq!(r, Ok(10));
      // get number of atoms
      let r = get_int_data_from_comment_line("# Number of particles 684", "# Number of particles");
      assert_eq!(r, Ok(684));

      let r = get_int_data_from_comment_line("# Timestep 0.0", "# Timestep");
      assert!(r.is_err());
      let r = get_int_data_from_comment_line("12 22\n", "# Timestep");
      assert!(r.is_err());
  }
#+end_src

*** cmdline
**** main
提供命令行操作, 读入待分析文件路径.
#+name: b8ea57f0-b549-4fa0-ac1a-abf83009009e
#+BEGIN_SRC rust
  /// get file name from command line argument
  fn get_filenames() -> (String, String) {
      use clap::{App, Arg, AppSettings};

      let app = App::new("reaxa");

      let matches = App::new("reaxa")
          .version("0.1.0")
          .author("Wenping Guo <winpng@gmail.com>")
          .about("a tool for analysis of lammps/reaxff reaction trajectory")
          .arg(
              Arg::with_name("debug")
                  .help("debug switch")
                  .long("debug")
                  .multiple(true)
                  .short("d")
          )
          .arg(
              Arg::with_name("input")
                  .help("set input file name")
                  .index(1)
                  .required(true)
          )
          .arg(
              Arg::with_name("output")
                  .help("set output file name")
                  .index(2)
                  .required(true)
          )
          .setting(AppSettings::ArgRequiredElseHelp)
          .get_matches();

      // It's safe to call unwrap() because of the required options we set above
      let input = matches.value_of("input").unwrap();
      let out = matches.value_of("output").unwrap();

      (input.to_string(), out.to_string())
  }

  fn main() {
      let (inputfile, outputfile) = get_filenames();
      create_terse_copy_of_lammps_bonds_file(&inputfile, &outputfile);
  }
#+END_SRC

* reaxb
分析reaxa生成的轨迹文件.
** cargo
#+name: d5f68605-90cb-4b2b-b316-2025d935c17b
#+BEGIN_SRC conf :tangle reaxb/Cargo.toml
  [package]
  name = "reaxb"
  version = "0.1.0"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  petgraph = "*"
  clap = "*"
  approx = "*"
  cgmath = "*"
#+END_SRC

** src
*** main.rs
:PROPERTIES:
:header-args: :tangle reaxb/src/main.rs
:END:

这里只放与命令行交互有关的代码.
**** globals
#+name: 68b8f3aa-b3f8-43c0-8b4d-c3165b146535
#+begin_src rust
  extern crate reaxb;
  extern crate clap;

  use std::fs::File;
  use std::error::Error;
  use std::io::{self, BufReader};
  use std::io::prelude::*;
  use std::collections::HashMap;
  use std::path::Path;

  use clap::{App, Arg, AppSettings};
  use reaxb::{extract_frame, analyze_frames};
#+end_src

**** main
提供命令行操作, 读入待分析文件路径.
***** Config
#+name: 25390ea6-8bf3-4083-a422-f9e628299efc
#+begin_src rust
  struct Config {
      inpfile  : Option<String>,
      extract  : bool,
      timestep : usize,
      outfile  : Option<String>,
      maxcols  : usize,
  }

  impl Config {
      fn new() -> Self {
          Config {
              inpfile  : None,
              extract  : false,
              timestep : 0,
              outfile  : None,
              maxcols  : 100,
          }
      }
  }
#+end_src

***** fn parse_args
#+name: b8ea57f0-b549-4fa0-ac1a-abf83009009e
#+BEGIN_SRC rust
  /// get file name from command line argument
  fn parse_args() -> Result<Config, Box<Error>> {
      let matches = App::new("reaxb")
          .version("0.1")
          .author("Wenping Guo <winpng@gmail.com>")
          .about("tools for lammps/reaxff reaction trajectory analysis")
          .arg(
              Arg::with_name("debug")
                  .help("debug switch")
                  .long("debug")
                  .multiple(true)
                  .short("d")
          )
          .arg(
              Arg::with_name("extract")
                  .help("extract structure on a specific timestep")
                  .long("extract")
                  .short("e")
                  .value_name("TIMESTEP")
                  .takes_value(true)
          )
          .arg(
              Arg::with_name("maxcols")
                  .help("set max columns in fragment analysis report")
                  .long("maxcols")
                  .short("m")
                  .value_name("NCOLUMNS")
                  .takes_value(true)
          )
          .arg(
              Arg::with_name("input")
                  .help("set input file name")
                  .value_name("INPUT-FILE")
                  .index(1)
                  .required(true)
          )
          .arg(
              Arg::with_name("output")
                  .help("set output file name")
                  .value_name("OUTPUT-FILE")
                  .index(2)
                  .required(true)
          )
          .setting(AppSettings::ArgRequiredElseHelp)
          .get_matches();

      let mut config = Config::new();
      if let Some(r) = matches.value_of("extract") {
          config.extract = true;
          match r.parse::<usize>() {
              Ok(v) => {
                  config.timestep = v;
              }
              Err(why) => {
                  let msg = format!("timestep is expected to be integer, but found: {}", r);
                  Err(msg)?;
              },
          }
      }

      if let Some(r) = matches.value_of("input") {
          config.inpfile = Some(r.to_string());
      } else {
          Err("input file is required!")?;
      }

      if let Some(r) = matches.value_of("output") {
          config.outfile = Some(r.to_string());
      } else {
          Err("output file is required!")?;
      }

      if let Some(r) = matches.value_of("maxcols") {
          config.maxcols = r.parse().unwrap();
      }

      Ok(config)
  }

#+END_SRC

***** fn main
#+name: 0176a8ca-12d4-4334-9fa5-6093ceddb854
#+begin_src rust
  fn main() {
      let config = parse_args().unwrap();
      let inpfile = config.inpfile.unwrap();
      let outfile = config.outfile.unwrap();

      if config.extract {
          println!("extract structure on timestep {} from file: {}", config.timestep, inpfile);
          println!("structure will be saved as: {}", &outfile);

          match extract_frame(&inpfile, config.timestep, &outfile) {
              Ok(r) => {
                  println!("Done. CIF file saved as {}.", outfile);
              },
              Err(why) => {
                  println!("Failed: {:}", why);
              },
          }
      } else {
          println!("fragment analysis of trajectory file: {:}", inpfile);
          match analyze_frames(&inpfile, &outfile, config.maxcols) {
              Ok(r) => {
                  println!("Done. report file saved as {}", outfile);
              },
              Err(why) => {
                  println!("Failed: {:}", why);
              },
          }
      }
  }
#+end_src

*** lib.rs
:PROPERTIES:
:header-args: :tangle reaxb/src/lib.rs
:END:
这里定义其它模块化的功能代码. 相当于python中的__init__.py?
**** globals
#+name: 68b8f3aa-b3f8-43c0-8b4d-c3165b146535
#+begin_src rust
  extern crate petgraph;
  extern crate cgmath;

  #[macro_use]
  extern crate approx;

  mod atoms;
  mod graph;
  mod lammps;

  use std::collections::HashMap;
  pub use lammps::{extract_frame, analyze_frames};
#+end_src

**** structs
#+name: 593685c3-b67d-43c2-95f8-c9fc86f6c5f8
#+begin_src rust
  pub struct Frame {
      pub timestep: usize,
      pub natoms: usize,
      pub fragments: HashMap<String, usize>,
      pub positions: HashMap<usize, [f64; 3]>,
      pub cell: [[f64; 3]; 3],
  }

  impl Frame {
      pub fn new() -> Frame{
          let map1: HashMap<String, usize> = HashMap::new();
          let map2: HashMap<usize, [f64; 3]> = HashMap::new();

          Frame {
              timestep: 0,
              natoms: 0,
              fragments: map1,
              positions: map2,
              cell: [[0_f64; 3]; 3],
          }
      }
  }
#+end_src

*** atoms.rs
:PROPERTIES:
:header-args: :tangle reaxb/src/atoms.rs
:END:
**** globals
#+name: 8da0ca06-6b0c-4d1b-8eec-827c7459cf2b
#+begin_src rust
  use std::collections::HashMap;
  use std::path::Path;
  use std::error::Error;
  use std::fs::File;
  use std::io::{self, BufReader, BufWriter};
  use std::io::Write;
#+end_src

**** atom
定义与Atom相关的元信息
#+name: 43366bc0-f1ca-4338-9289-0f637affbfda
#+begin_src rust
  #[derive(Debug, Default, Clone)]
  pub struct AtomData{
      pub index: usize,
      pub symbol: String,
      pub neighbors: Vec<usize>,
      pub charge: f64,
      pub position: [f64; 3],
  }
#+end_src

定义生成函数, 方便使用.
#+name: 455910f5-3d04-48b0-a9cc-a46516ba6c1c
#+begin_src rust
  impl AtomData {
      pub fn new() -> Self {
          let ns:Vec<usize> = Vec::new();

          AtomData {
              index: 0,
              charge: 0.0,
              symbol: "H".to_string(),
              neighbors: ns,
              position: [0.0; 3],
          }
      }
  }
#+end_src

**** trajectory frame
#+name: ec36c72e-4d04-447e-bd3d-bd4c6c3c49bb
#+begin_src rust
  // data structure for a single frame
  pub struct TrajectoryFrame {
      pub timestep    : usize,            // current timestep
      pub natoms      : usize,
      pub cell        : [[f64; 3]; 3],
      pub cell_origin : [f64; 3],
      pub symbols     : HashMap<usize, String>,
      pub positions   : HashMap<usize, [f64; 3]>,
      pub neighbors   : HashMap<usize, Vec<usize>>,
  }
#+end_src

#+name: 8a0cf3ff-227f-493b-aa5e-20ac3cac8f5c
#+begin_src rust
  impl TrajectoryFrame {
      pub fn new() -> Self {
          let positions: HashMap<usize, [f64; 3]> = HashMap::new();
          let symbols  : HashMap<usize, String> = HashMap::new();
          let cell = [[0_f64; 3]; 3];
          let neighbors: HashMap<usize, Vec<usize>> = HashMap::new();

          TrajectoryFrame {
              timestep    : 0,
              natoms      : 0,
              positions   : positions,
              symbols     : symbols,
              cell        : cell,
              cell_origin : [0_f64; 3],
              neighbors   : neighbors,
          }
      }
  }
#+end_src

**** cell
***** info
1. [X] 将cartesian坐标转为fractional坐标
2. [X] 将cell vectors转为cell parameters(a, b, c, alpha, beta, gamma)
3. [X] 还需要计算cell origin

: inverse = np.linalg.inv(matrix.T)
: inverse.dot(cartesian)

#+name: e144d691-9579-4fc5-ab53-0f3e139b3169
#+BEGIN_SRC text :tangle no
  cell vectors
  5.0900002 0.0 0.0
  0.0 6.7399998 0.0
  0.0 0.0 4.5300002
  Cartesian
  2.1832399 1.685 3.8505002
  6.9067602 5.0549998 0.6795
  4.3617602 5.0549998 1.5855
  4.72824 1.685 2.9445
  2.94674 0.42462 1.48584
#+END_SRC

#+name: 70e96a58-af80-4acc-abb8-e10a4e531a18
#+BEGIN_SRC text :tangle no
  _cell_length_a       5.0900
  _cell_length_b       6.7400
  _cell_length_c       4.5300
  _cell_angle_alpha     90.0000
  _cell_angle_beta     90.0000
  _cell_angle_gamma     90.0000

  C   C1         0.42893     0.25000     0.85000
  C   C2         1.35693     0.75000     0.15000
  C   C3         0.85693     0.75000     0.35000
  C   C4         0.92893     0.25000     0.65000
  C   C5         0.57893     0.06300     0.32800
#+END_SRC

***** src
#+name: 6746df7d-0871-43bf-98cd-2e00e15020a5
#+begin_src rust
  use cgmath::{Vector3, Matrix3, Point3, Deg};
  use cgmath::prelude::*;

  fn cart_to_frac(matrix: Matrix3<f64>,
                  coordinates: Vec<Vector3<f64>>) -> Vec<Vector3<f64>>
  {
      let mut fractional = Vec::new();
      let inv = matrix.transpose().invert().unwrap();
      for v in coordinates {
          fractional.push(inv*v);
      }

      fractional
  }
#+end_src

最近邻镜像原子
#+name: c57f4ca0-4e68-4e30-a91b-7cbd47b7071c
#+begin_src rust
  use std::f64;

  fn get_nearest_image(
      cell: Matrix3<f64>,
      position1: Point3<f64>,
      position2: Point3<f64>) -> (Vector3<f64>, f64)
  {
      let d = position1.distance(position2);

      // loop 27 possible point images
      let relevant_images = [-1, 0, 1];
      let mut distance = f64::MAX;
      let mut image = Vector3::from_value(0_f64);
      for x in relevant_images.iter() {
          for y in relevant_images.iter() {
              for z in relevant_images.iter() {
                  let p = position2 + (*x as f64)*cell.x + (*y as f64)*cell.y + (*z as f64)*cell.z;
                  let d = position1.distance(p);
                  if d < distance {
                      distance = d;
                      image.x = *x as f64;
                      image.y = *y as f64;
                      image.z = *z as f64;
                  }
              }
          }
      }

      (image, distance)
  }

  #[test]
  fn test_get_nearest_image() {
      let mat1 = Matrix3::new(5.09, 0.00, 0.00,
                              0.00, 6.74, 0.00,
                              0.00, 0.00, 4.53);

      let p1  = Point3::new(0.18324000,   1.68500000,   3.85050000);
      let p13 = Point3::new(4.53010000,   1.68500000,   2.03850000);
      let p10 = Point3::new(0.94674000,   2.94538000,   1.48584000);
      let dp1_13 = 1.95847;
      let dp1_10 = 2.61920;

      let (image, d) = get_nearest_image(mat1, p1, p13);
      assert_relative_eq!(d, dp1_13, epsilon=1e-4);
      assert_relative_eq!(image.x, -1.0, epsilon=1e-4);
      assert_relative_eq!(image.y, 0.0, epsilon=1e-4);
      assert_relative_eq!(image.z, 0.0, epsilon=1e-4);

      let (image, d) = get_nearest_image(mat1, p1, p10);
      assert_relative_eq!(d, dp1_10, epsilon=1e-4);
  }
#+end_src

#+name: c90b9d01-096f-47c1-bbfd-2649862e61dc
#+begin_src rust
  fn cell_vectors_to_parameters(matrix: Matrix3<f64>) -> (f64, f64, f64, f64, f64, f64) {
      let a = matrix.x.magnitude();
      let b = matrix.y.magnitude();
      let c = matrix.z.magnitude();

      let alpha: Deg<_> = matrix.y.angle(matrix.z).into();
      let beta: Deg<_> = matrix.x.angle(matrix.z).into();
      let gamma: Deg<_> = matrix.x.angle(matrix.y).into();

      (a, b, c, alpha.0, beta.0, gamma.0)
  }
#+end_src

#+name: 9cab3b07-9781-48cd-a6fb-e6ee248b93dd
#+begin_src rust
  #[test]
  fn test_cell() {
      // ovito/tests/files/LAMMPS/multi_sequence_1.dump
      let mat1 = Matrix3::new(5.09, 0.00, 0.00,
                              0.00, 6.74, 0.00,
                              0.00, 0.00, 4.53);
      let inv = mat1.transpose().invert().unwrap();

      let v1 = Vector3::new(2.1832, 1.6850, 3.8505);
      let v2 = Vector3::new(6.9068, 5.0550, 0.6795);
      let v3 = Vector3::new(4.3618, 5.0550, 1.5855);

      let fracs = cart_to_frac(mat1, vec![v1, v2, v3]);
      assert_relative_eq!(fracs[0].x, 0.4289, epsilon=1e-3);
      assert_relative_eq!(fracs[0].y, 0.2500, epsilon=1e-3);
      assert_relative_eq!(fracs[0].z, 0.8500, epsilon=1e-3);
      assert_relative_eq!(fracs[1].x, 1.3569, epsilon=1e-3);
      assert_relative_eq!(fracs[2].z, 0.3500, epsilon=1e-3);

      let mat2 = Matrix3::new(15.3643, 0.0, 0.0,
                              4.5807, 15.5026, 0.0,
                              0.0, 0.0, 17.4858);

      let (a, b, c, alpha, beta, gamma) = cell_vectors_to_parameters(mat2);
      assert_relative_eq!(a, 15.3643, epsilon=1e-4);
      assert_relative_eq!(b, 16.1652, epsilon=1e-4);
      assert_relative_eq!(c, 17.4858, epsilon=1e-4);

      assert_relative_eq!(alpha, 90.0, epsilon=1e-4);
      assert_relative_eq!(beta, 90.0, epsilon=1e-4);
      assert_relative_eq!(gamma, 73.5386, epsilon=1e-4);
  }
#+end_src

**** cif file
***** info
以cif文件格式输出结构信息

frame里需要具有的信息:
- timestep
- natoms
- positions
- neighbors
- symbols
- cell

cif需要输出bonds信息, 包括边界原子与邻近镜像原子的成键.

***** src
#+name: fb3fb6d8-9ae3-4b29-a7c6-92c61776c867
#+begin_src rust
  pub fn write_as_cif(frame: TrajectoryFrame, path: &Path) -> Result<(), Box<Error>>{
      let mut lines = String::new();

      // meta inforation
      lines.push_str("data_test\n");
      lines.push_str("_audit_creation_method            'gosh'\n");
      lines.push_str("_symmetry_space_group_name_H-M    'P1'\n");
      lines.push_str("_symmetry_Int_Tables_number       1\n");
      lines.push_str("_symmetry_cell_setting            triclinic\n");
      lines.push_str("\n");

      // cell parameters
      lines.push_str("loop_\n");
      lines.push_str("_symmetry_equiv_pos_as_xyz\n");
      lines.push_str(" x,y,z\n");
      let cell = Matrix3::new(frame.cell[0][0],
                              frame.cell[0][1],
                              frame.cell[0][2],
                              frame.cell[1][0],
                              frame.cell[1][1],
                              frame.cell[1][2],
                              frame.cell[2][0],
                              frame.cell[2][1],
                              frame.cell[2][2]);
      let (a, b, c, alpha, beta, gamma) = cell_vectors_to_parameters(cell);

      lines.push_str(&format!("_cell_length_a     {:10.4}\n", a));
      lines.push_str(&format!("_cell_length_b     {:10.4}\n", b));
      lines.push_str(&format!("_cell_length_c     {:10.4}\n", c));
      lines.push_str(&format!("_cell_angle_alpha  {:10.4}\n", alpha));
      lines.push_str(&format!("_cell_angle_beta   {:10.4}\n", beta));
      lines.push_str(&format!("_cell_angle_gamma  {:10.4}\n", gamma));
      lines.push_str("\n");

      // atom fractional coordinates
      lines.push_str("loop_\n");
      lines.push_str("_atom_site_type_symbol\n");
      lines.push_str("_atom_site_label\n");
      lines.push_str("_atom_site_fract_x\n");
      lines.push_str("_atom_site_fract_y\n");
      lines.push_str("_atom_site_fract_z\n");

      let cell_origin = Vector3::new(frame.cell_origin[0], frame.cell_origin[1], frame.cell_origin[2]);
      for index in 1..(frame.natoms+1) {
          let position = frame.positions.get(&index).unwrap();
          let symbol = frame.symbols.get(&index).unwrap();
          let name = format!("{}{}", symbol, index);
          let coords = Vector3::new(position[0], position[1], position[2]) - cell_origin;
          let v = cell.transpose().invert().unwrap()*coords;
          let s = format!("{:4}{:6}{:12.5}{:12.5}{:12.5}\n", symbol, name, v.x, v.y, v.z);
          lines.push_str(&s);
      }

      // bonds
      if frame.neighbors.len() > 0 {
          lines.push_str("loop_\n");
          lines.push_str("_geom_bond_atom_site_label_1\n");
          lines.push_str("_geom_bond_atom_site_label_2\n");
          lines.push_str("_geom_bond_distance\n");
          lines.push_str("_geom_bond_site_symmetry_2\n");
          lines.push_str("_ccdc_geom_bond_type\n");
          for current in 1..(frame.natoms+1) {
              let symbol1 = frame.symbols.get(&current).unwrap();
              let name1 = format!("{}{}", symbol1, current);
              let p1 = frame.positions.get(&current).unwrap();
              let p1 = Point3::new(p1[0], p1[1], p1[2]) - cell_origin;

              let connected = frame.neighbors.get(&current).unwrap();
              for other in connected {
                  if *other > current {
                      let symbol2 = frame.symbols.get(&other).unwrap();
                      let name2 = format!("{}{}", symbol2, other);
                      let p2 = frame.positions.get(&other).unwrap();
                      let p2 = Point3::new(p2[0], p2[1], p2[2]) - cell_origin;
                      let (image, distance) = get_nearest_image(cell, p1, p2);
                      if image.x == 0. && image.y == 0. && image.z == 0. {
                          lines.push_str(&format!("{:6} {:6} {:6.3} {:6} S\n", name1, name2, distance, "."));
                      } else {
                          let symcode = get_image_symcode(image);
                          lines.push_str(&format!("{:6} {:6} {:6.3} {:6} S\n", name1, name2, distance, symcode));
                          let (image, distance) = get_nearest_image(cell, p2, p1);
                          let symcode = get_image_symcode(image);
                          lines.push_str(&format!("{:6} {:6} {:6.3} {:6} S\n", name2, name1, distance, symcode));
                      }
                  }
              }
          }
      }

      // save as a file
      let f = File::create(path)?;
      let mut writer = BufWriter::new(&f);
      writer.write_all(&lines.as_bytes())?;

      Ok(())
  }
#+end_src

#+name: bacd2858-ded3-4982-a986-dbee08aa6a51
#+begin_src rust
  fn get_image_symcode(image: Vector3<f64>) -> String {
      let mut symcode = String::new();

      symcode.push_str("1_");
      symcode.push_str(&format!("{:1}", image.x + 5_f64));
      symcode.push_str(&format!("{:1}", image.y + 5_f64));
      symcode.push_str(&format!("{:1}", image.z + 5_f64));

      symcode
  }


  #[test]
  fn test_get_image_symcode() {
      let v = Vector3::new(1., 0., 0.);
      let x = get_image_symcode(v);
      assert_eq!(x, "1_655");
      let v = Vector3::new(0., 0., 0.);
      let x = get_image_symcode(v);
      assert_eq!(x, "1_555");
  }
#+end_src

***** tests
#+name: 95c7d059-a138-4de7-8325-4439cf548d0e
#+begin_src rust
  #[test]
  fn test_wirte_cif() {
      let mut frame = TrajectoryFrame::new();
      let path = Path::new("test.cif");

      frame.timestep = 0;

      let cell = [[15.3643, 0.0, 0.0], [4.5807, 15.5026, 0.0], [0.0, 0.0, 17.4858]];
      frame.cell = cell;

      let mut positions = HashMap::new();
      positions.insert(1, [2.1832, 1.6850, 3.8505]);
      positions.insert(2, [6.9068, 5.0550, 0.6795]);
      frame.positions = positions;

      let mut symbols = HashMap::new();
      symbols.insert(1, "C".to_string());
      symbols.insert(2, "H".to_string());
      frame.symbols = symbols;

      write_as_cif(frame, &path);
  }
#+end_src

**** 定义最简单的原子结构信息.
#+name: 1f84ef01-7ddb-4295-8521-c29ad7d7e059
#+begin_src rust
  use std::hash::{Hash, Hasher};
  use std::cmp::Ordering;

  #[derive (Default, Debug, Clone, Copy)]
  /// simple atom data structure
  pub struct Atom {
      pub index: u64,
      pub symbol: &'static str,
  }

  impl PartialEq for Atom {
      fn eq(&self, other: &Atom) -> bool {
          self.index == other.index
      }
  }

  impl Eq for Atom {}

  impl Hash for Atom {
      fn hash<H: Hasher>(&self, state: &mut H) {
          self.index.hash(state);
      }
  }

  impl Ord for Atom {
      fn cmp(&self, other: &Atom) -> Ordering {
          self.index.cmp(&other.index)
      }
  }

  impl PartialOrd for Atom {
      fn partial_cmp(&self, other: &Atom) -> Option<Ordering> {
          Some(self.cmp(other))
      }
  }

  #[test]
  fn test_atom() {
      let a = Atom{
          index: 1,
          symbol: "H",
      };

      let b = Atom {
          index: 2,
          symbol: "H",

      };
      let mut c = Atom {
          index: 1,
          symbol: "H",
      };

      assert!(a != b);
      assert!(a == c);

      assert!(a.index == 1);
      assert!(a.symbol == "H");

      c.symbol = "C";
      assert!(c.symbol == "C");
  }
#+end_src

**** from symbols to formula
实现从元素符号列表到分子式.
#+name: 27fa4abe-d98c-4dd4-8695-e4b4f807cabc
#+begin_src rust
  // it is better to use generics function,
  // but it is really difficult for me now
  pub fn get_reduced_formula(symbols: &[&str]) -> String {
      // 1. count symbols: CCCC ==> C 4
      let mut counts = HashMap::new();
      for x in symbols {
          let c = counts.entry(x).or_insert(0);
          ,*c += 1;
      }

      let mut syms: Vec<String> = Vec::new();
      let mut to_append = String::new();
      // 2. format the formula
      for (k, v) in counts {
          // 2.1 omit number if the count is 1: C1H4 ==> CH4
          let mut s = String::new();
          if v > 1 {
              s = v.to_string();
          }
          // 2.2 special treatments for C and H
          let reduced = format!("{}{}", k, s);
          if *k == "C" {
              syms.insert(0, reduced);
          } else if *k == "H" {
              to_append = reduced;
          } else {
              syms.push(reduced);
          }
      }
      // 3. final output
      syms.push(to_append);
      let formula = syms.join("");
      formula
  }

  #[test]
  fn test_formula() {
      let symbols   = vec!["C", "H", "C", "H", "H", "H"];
      let formula = get_reduced_formula(&symbols);
      assert!(formula == "C2H4".to_string());
      let symbols   = vec!["C", "H", "C", "H", "H", "O", "H", "O"];
      let formula = get_reduced_formula(&symbols);
      println!("{:?}", formula);
      assert!(formula == "C2O2H4".to_string());
  }
#+end_src
*** graph.rs
:PROPERTIES:
:header-args: :tangle reaxb/src/graph.rs
:END:
**** globals
#+name: 8da0ca06-6b0c-4d1b-8eec-827c7459cf2b
#+begin_src rust
  use std::collections::HashMap;

  use petgraph::prelude::*;
  use petgraph as pg;

  use atoms::get_reduced_formula;
  use atoms::AtomData;
#+end_src

**** fragments
#+name: 080d17e9-5876-4808-8e5a-a181129da4fd
#+begin_src rust
  pub fn fragments_from_atoms(atoms: &Vec<AtomData>) -> HashMap<String, usize>
  {
      let mut graph = Graph::new_undirected();

      // add nodes
      for d in atoms {
          graph.add_node(&d.symbol);
      }

      // update edges
      for d in atoms {
          let icurrent = NodeIndex::new(&d.index-1);
          for x in &d.neighbors {
              let iother = NodeIndex::new(x - 1);
              graph.update_edge(icurrent, iother, 1);
          }
      }

      // get fragments from connected components
      let sccs = pg::algo::kosaraju_scc(&graph);
      let mut counts = HashMap::new();
      let mut symbols = vec![];
      for x in sccs {
          symbols.clear();
          for index in x {
              let sym = &graph[index];
              symbols.push(sym.as_str());
          }
          // count formulas
          let formula = get_reduced_formula(&symbols);
          let c = counts.entry(formula).or_insert(0);
          ,*c += 1;
      }

      counts
  }
#+end_src

*** lammps.rs
:PROPERTIES:
:header-args: :tangle reaxb/src/lammps.rs
:END:
总体思路:
- 从data文件中读入总原子数, 原子对应的原子类型(元素符号)
- 从简化的bonds文件中读入某帧时的timestep, 键连关系.
- 使用图论来分析某帧时的fragments(connected components), 某fragments的个数.
- 等所有轨迹解析完成, 输出总表: timestep vs fragments (counts)

附加功能:
- 提取特定timestep的结构
- 同时读取bonds文件中的键连信息
- 以CIF文件格式输出

**** globals
#+name: 8da0ca06-6b0c-4d1b-8eec-827c7459cf2b
#+begin_src rust
  use std::fs::File;
  use std::error::Error;
  use std::io::{self, BufReader, BufWriter};
  use std::io::prelude::*;
  use std::collections::HashMap;
  use std::path::Path;

  use petgraph::prelude::*;
  use petgraph as pg;

  use atoms::{AtomData, TrajectoryFrame, write_as_cif};
  use ::Frame;
  use graph::fragments_from_atoms;
#+end_src

**** parse lammps files
读入多个lammps文件. 问题: data, bonds, dump这三个文件名不一定相同.
***** extract frame structure
提出特定frame对应的结构, 生成cif文件.
- 元素信息: symbols
- 键连信息: bonds
- 结构信息: dump, cell

#+name: 30c60549-db69-4b1b-b0e5-33904c16a8b9
#+begin_src rust
  pub fn extract_frame(filename: &str, target_timestep: usize, ciffile: &str) -> Result<(), Box<Error>>
  {
      // 1. guess required lammps files from input filename
      let path = Path::new(filename);
      let path_lammps_data = path.with_extension("data");
      let path_lammps_dump = path.with_extension("dump");
      let path_lammps_bonds = path.with_extension("bonds-terse");

      if ! path_lammps_data.is_file() {
          let msg = format!("data file not found: {:}", path_lammps_data.display());
          Err(msg)?;
      }
      if ! path_lammps_bonds.is_file() {
          let msg = format!("bonds file not found: {:}", path_lammps_bonds.display());
          Err(msg)?;
      }

      if ! path_lammps_dump.is_file() {
          let msg = format!("dump file not found: {:}", path_lammps_dump.display());
          Err(msg)?;
      }

      // get positions from dump file
      let mut frame = get_frame_from_lammps_dump_file(&path_lammps_dump, target_timestep)?;

      // get symbols from data file
      frame.symbols = parse_lammps_data_file(&path_lammps_data)?;

      // assign connectivity
      frame.neighbors = get_connectivity_from_terse_bonds_file(&path_lammps_bonds, target_timestep)?;

      let path = Path::new(ciffile);
      write_as_cif(frame, &path);

      Ok(())
  }
#+end_src

***** fragment analysis
#+name: 1d1ee6e3-9786-42f5-bc5b-e5542d5e6149
#+begin_src rust
  pub fn analyze_frames(filename: &str, outfile: &str, maxcols: usize) -> Result<(), Box<Error>>{
      let frames = parse_lammps_files(filename)?;
      write_formated_text(&frames, outfile, maxcols)?;

      Ok(())
  }
#+end_src

#+name: 2085aabc-b09b-4084-88d1-33699881e5e3
#+begin_src rust
  pub fn parse_lammps_files(filename: &str) -> Result<Vec<Frame>, Box<Error>> {
      // 1. guess required lammps files from input filename
      let path = Path::new(filename);
      let path_lammps_data = path.with_extension("data");
      let path_lammps_dump = path.with_extension("dump");
      let path_lammps_bonds = path.with_extension("bonds-terse");

      if ! path_lammps_data.is_file() {
          let msg = format!("data file not found: {:}", path_lammps_data.display());
          Err(msg)?;
      }
      if ! path_lammps_bonds.is_file() {
          let msg = format!("bonds file not found: {:}", path_lammps_bonds.display());
          Err(msg)?;
      }

      // read atom indices and symbols
      let symbols = parse_lammps_data_file(&path_lammps_data)?;

      // assign connectivity
      let frames = parse_terse_bonds_file(&path_lammps_bonds, &symbols);

      frames
  }
#+end_src

#+name: 4540ac95-d7d0-42a2-aef3-bcee0abc5586
#+begin_src rust
  pub fn write_formated_text(frames: &Vec<Frame>, outfile: &str, max_columns: usize) -> Result<(), Box<Error>>{
      // create output file
      let f = File::create(outfile)?;
      let mut writer = BufWriter::new(f);

      let mut species:HashMap<String, usize> = HashMap::new();
      for frame in frames {
          for (k, v) in &frame.fragments {
              let x = species.entry(k.to_string()).or_insert(0_usize);
              ,*x += v;
          }
      }

      let mut count_vec: Vec<_> = species.iter().collect();
      count_vec.sort_by_key(|k| k.1);
      count_vec.reverse();

      let vs:Vec<String> = count_vec.iter().map(|x| x.0.to_string()).collect();
      writer.write("Timestep ".as_bytes());

      let mut mc = vs.len();
      if max_columns < mc {
          mc = max_columns;
      }
      let vs = &vs[..mc];
      writer.write(format!("{:}\n", vs.join(" ")).as_bytes());

      for frame in frames {
          let s = format!("{:^width$}", frame.timestep, width="Timestep ".len());
          writer.write(s.as_bytes());
          let mut lst = Vec::new();
          for k in vs.iter() {
              let count = frame.fragments.get(k).unwrap_or(&0_usize);
              lst.push(format!("{:^width$}", count, width=k.len()));
          }
          let s = format!("{}\n", lst.join(" "));
          writer.write(s.as_bytes());
      }

      Ok(())
  }
#+end_src
**** data file
***** info
从lammps data输入文件中读入结构信息.
格式参考: [[http://lammps.sandia.gov/doc/2001/data_format.html][LAMMPS Data Format]]

从文件名猜出其它需要的文件, 比如:
: V2O5_010_MeOH_rand_nvt_650_20.bonds => V2O5_010_MeOH_rand_nvt_650_20.data ==> V2O5_010_MeOH_rand_nvt_650_20.dump

读取lammps的data文件. 读入信息包括:
1. 总原子数.
2. 总原子类型数.
3. 原子数型编号与元素的对应关系.
4. 体系中所有的原子, 元素, 坐标等.

***** src
- 关键信息: 所有原子对应的元素类型.
- 数据类型选择HashMap, key为index, value为元素符号

#+name: 1f4bb42e-6c9c-41d1-b9f3-e0908813187a
#+begin_src rust
  /// read data from lammps .data file
  fn parse_lammps_data_file(path: &Path) -> Result<HashMap<usize, String>, Box<Error>>
  {
      eprintln!("reading data file: {}", path.display());

      let fp = File::open(path)?;
      let mut reader = BufReader::new(fp);
      let mut lines_iter = reader.lines().peekable();

      // sanity check
      if let Some(&Ok(ref firstline)) = lines_iter.peek() {
          if ! firstline.starts_with("LAMMPS data file") {
              let msg = format!("read in a wrong file: {}", firstline);
              Err(msg)?;
          }
      } else {
          let msg = format!("Expect more lines: {}", path.display());
          Err(msg)?;
      }

      // skip the first two lines
      for _ in 0..2 {
          lines_iter.next();
      }

      // 1. read number of total atoms
      // 684  atoms
      let mut natoms = 0;
      if let Some(line) = lines_iter.next() {
          let line = line?;
          assert!(line.contains(" atoms"), format!("cannot find number of atoms: {}", line));
          let mut attrs = line.split_whitespace();
          if let Some(s) = attrs.nth(0) {
              natoms = s.parse().unwrap();
          } else {
              let msg = format!("failed to get natoms: {}", line);
              Err(msg)?;
          }
      } else {
          Err("data file is incomplete: failed to get natoms!")?;
      }

      // 2. read in number of atom types
      let mut natom_types = 0_usize;
      loop {
          if let Some(line) = lines_iter.next() {
              let line = line?;
              if line.ends_with("atom types") {
                  if let Some(n) = line.split_whitespace().nth(0) {
                      natom_types = n.parse().unwrap();
                  }
                  break;
              }
          } else {
              Err("cannot find atom types lines in lammps data file")?;
          }
      }

      // 3. parse atom types
      // NOTE: element symbol is supposed to be after `#`
      //     1  50.941500   # V
      assert!(natom_types > 0);
      let mut mapping_symbols = HashMap::new();
      loop {
          if let Some(line) = lines_iter.next() {
              let line = line?;
              if line.starts_with("Masses") {
                  // skip one blank line
                  lines_iter.next();
                  // mapping: atom_index ==> atom_symbol
                  for _ in 0..natom_types {
                      if let Some(line) = lines_iter.next() {
                          let line = line?;
                          let mut attrs = line.split_whitespace();
                          let k = attrs.nth(0).unwrap();
                          let v = attrs.last().unwrap();
                          mapping_symbols.insert(k.to_string(), v.to_string());
                      }
                  }
                  break;
              }
          } else {
              Err("failed to read Masses section")?;
          }
      }

      // 4. read in atom index and atom type
      assert!(natoms > 0);

      let mut symbols = HashMap::new();
      loop {
          if let Some(line) = lines_iter.next() {
              let line = line?;
              if line.starts_with("Atom") {
                  // skip one blank line
                  lines_iter.next();
                  for _ in 0..natoms {
                      if let Some(line) = lines_iter.next() {
                          let line = line?;
                          let mut attrs = line.split_whitespace();
                          let index = attrs.next().unwrap();
                          let t = attrs.next().unwrap();
                          let index = index.parse().unwrap();
                          let symbol = mapping_symbols.get(t).unwrap().to_string();
                          symbols.insert(index, symbol);
                      } else {
                          Err("Atom records are incomplete.")?;
                      }
                  }
                  break;
              }
          } else {
              Err("cannot find Atom lines in lammps data file")?;
          }
      }

      Ok(symbols)
  }
#+end_src

***** test
#+name: 52bb7570-33ac-44ae-950b-c7d67d597e76
#+begin_src rust
  #[test]
  #[ignore]
  fn test_parse_data_file() {
      let filename = "/home/ybyygu/Incoming/FeC reaxff tests/FeCO/terse-tests/test.data";
      let path = Path::new(&filename);
      let symbols = parse_lammps_data_file(&path);
      println!("{:?}", symbols);
  }
#+end_src
**** dump file
扩展名多数为dump, 有些也为lammpstrj等.

***** lammps dump frame
提取特定帧对应的坐标信息.
****** src
#+name: daedfe6b-34ed-4dd1-94a2-4e698a00a42c
#+begin_src rust
  fn get_frame_from_lammps_dump_file (path: &Path, target_timestep: usize) -> Result<TrajectoryFrame, Box<Error>>
  {
      let fp = File::open(path)?;
      let mut reader = BufReader::new(fp);

      let mut frame = TrajectoryFrame::new();
      let mut natoms = 0_usize;
      let mut timestep = 0_usize;
      let mut buf = String::new();
      loop {
          // 0. sanity check
          buf.clear();
          let nb = reader.read_line(&mut buf)?;
          if nb <= 0 {
              eprintln!("reached the end of the file: {}", path.display());
              break;
          }
          assert!(buf.starts_with("ITEM: TIMESTEP"), format!("Expect the frame header, but: {}", buf));

          // 1. get current timestep
          buf.clear();
          let nb = reader.read_line(&mut buf)?;
          if nb <= 0 {
              Err("Expect more lines: failed to read timestep!")?;
          }
          timestep = buf.trim_right().parse()?;

          // 2. get number of atoms
          for i in 0..2 {
              buf.clear();
              let nb = reader.read_line(&mut buf)?;
              if nb > 0 {
                  if i == 1 {
                      natoms = buf.trim_right().parse()?;
                  }
              } else {
                  Err("Expect more lines: failed to read number of atoms!")?;
              }
          }

          // 3. get lammps box and atoms
          assert!(natoms > 0, buf);
          println!("current timestep = {:?}", timestep);
          if timestep < target_timestep {
              for _ in 0..(natoms + 5) {
                  let nb = reader.read_line(&mut buf)?;
                  if nb <= 0 {
                      Err("Expect more lines: failed to read lammps box and atoms")?;
                  }
              }
          } else if timestep == target_timestep {
              frame.timestep = timestep;
              frame.natoms = natoms;

              buf.clear();
              // 3.1 the lammps box
              for _ in 0..4 {
                  let nb = reader.read_line(&mut buf)?;
                  if nb <= 0 {
                      Err("Expect more lines: failed to read lammps box!")?;
                  }
              }
              let (cell, origin) = get_lammps_dump_box(&buf)?;
              frame.cell = cell;
              frame.cell_origin = origin;

              // 3.2 the atom records
              buf.clear();
              for _ in 0..(natoms+1) {
                  let nb = reader.read_line(&mut buf)?;
                  if nb <= 0 {
                      Err("Expect more lines: failed to read all atom records!")?;
                  }
              }
              let positions = get_lammps_dump_positions(&buf, natoms)?;
              frame.positions = positions;
              // ignore remaining lines
              break;
          } else {
              let msg = format!("Requested timestep {} not found in {}", target_timestep, path.display());
              Err(msg)?;
          }
      }

      Ok(frame)
  }
#+end_src
****** tests
#+name: 69313c0d-d969-40b4-a338-ff274407d54d
#+begin_src rust
  #[test]
  #[ignore]
  fn test_parse_lammps_dump_file() {
      let filename = "/home/ybyygu/Workspace/Programming/reaction-analysis/tests/FeCO/Fe100_8816_50CO_500_500K.dump";
      let path = Path::new(&filename);

      let frame = get_frame_from_lammps_dump_file(&path, 200_usize).unwrap();
      println!("{:?}", frame.positions);
  }
#+end_src

***** lammps dump box
****** info
正交格子(orthogonal simulation box)
#+BEGIN_EXAMPLE
  ITEM: BOX BOUNDS xx yy zz
  xlo xhi
  ylo yhi
  zlo zhi
#+END_EXAMPLE

: a = (xhi-xlo, 0, 0)
: b = (0, yhi-ylo, 0)
: c = (0, 0, zhi-zlo)

非正交(triclinic simulation boxes):
#+BEGIN_EXAMPLE
  ITEM: BOX BOUNDS xy xz yz xx yy zz
  xlo_bound xhi_bound xy
  ylo_bound yhi_bound xz
  zlo_bound zhi_bound yz
#+END_EXAMPLE

: a = (xhi-xlo, 0, 0)
: b = (xy, yhi-ylo, 0)
: c = (xz, yz, zhi-zlo)

: xlo_bound = xlo + MIN(0.0,xy,xz,xy+xz)
: xhi_bound = xhi + MAX(0.0,xy,xz,xy+xz)
: ylo_bound = ylo + MIN(0.0,yz)
: yhi_bound = yhi + MAX(0.0,yz)
: zlo_bound = zlo
: zhi_bound = zhi

用OVITO检查结构是否正确.

ovito的代码:
: Codes/ovito/src/plugins/particles/import/lammps/LAMMPSTextDumpImporter.cpp
mdtrj中的相关代码:
: Codes/mdtraj/mdtraj/formats/lammpstrj.py

References
- http://lammps.sandia.gov/doc/Section_howto.html#triclinic-non-orthogonal-simulation-boxes

****** src
#+name: 32374d0e-1d81-4ec0-a8b3-0fb7950a625a
#+begin_src rust
  use std::f64;

  enum BoxStyle {
      Orthogonal,
      Triclinic,
  }

  fn get_lammps_dump_box(txt: &str) -> Result<([[f64; 3]; 3], [f64; 3]), Box<Error>>{
      use self::BoxStyle::{Orthogonal, Triclinic};

      let mut lines_iter = txt.lines();

      let mut hi    = [0.0; 3];
      let mut lo    = [0.0; 3];
      let mut tilt  = [0.0; 3];
      let mut style = Orthogonal;

      if let Some(line) = lines_iter.next() {
          if line.starts_with("ITEM: BOX BOUNDS") {
              let attrs = line.split_whitespace();
              style = match attrs.count() {
                  6 => Orthogonal,
                  9 => Triclinic,
                  _ => Err(format!("unexpected box style: {}", &line))?,
              };

              for i in 0..3 {
                  if let Some(line) = lines_iter.next() {
                      let mut attrs:Vec<f64> = line.split_whitespace().map(|x| x.parse::<f64>().unwrap()).collect();
                      match style {
                          Orthogonal => {
                              lo[i] = attrs[0];
                              hi[i] = attrs[1];
                          },
                          Triclinic => {
                              lo[i] = attrs[0];
                              hi[i] = attrs[1];
                              tilt[i] = attrs[2];
                          },
                      }
                  } else {
                      Err("lammps box is incomplete!")?;
                  }
              }
          } else {
              let msg = format!("expect LAMMPS BOX header, but found: {}", &line);
              Err(msg)?;
          }
      } else {
          Err("why")?;
      }

      let mut va = [0.0; 3];
      let mut vb = [0.0; 3];
      let mut vc = [0.0; 3];
      let mut origin = lo;
      match style {
          Orthogonal => {
              va[0] = hi[0] - lo[0];
              vb[1] = hi[1] - lo[1];
              vc[2] = hi[2] - lo[2];
              origin = lo;
          },
          Triclinic  => {
              let xy = tilt[0];
              let xz = tilt[1];
              let yz = tilt[2];

              // x vector
              let xlo = lo[0] - [0.0, xy, xz, xy+xz].iter().fold(f64::MAX, |a, &b| a.min(b));
              let xhi = hi[0] - [0.0, xy, xz, xy+xz].iter().fold(f64::MIN, |a, &b| a.max(b));
              va[0] = xhi - xlo;
              // y vector
              let ylo = lo[1] - [0.0, yz].iter().fold(f64::MAX, |a, &b| a.min(b));
              let yhi = hi[1] - [0.0, yz].iter().fold(f64::MIN, |a, &b| a.max(b));
              vb[0] = xy;
              vb[1] = yhi - ylo;
              // z vector
              let zlo = lo[2];
              let zhi = hi[2];
              vc[0] = xz;
              vc[1] = yz;
              vc[2] = zhi - zlo;
              origin = [xlo, ylo, zlo];
          },
      }

      Ok(([va, vb, vc], origin))
  }
#+end_src

****** tests
#+name: 398e563b-0ad5-4845-a5c3-97c115748e74
#+begin_src rust
  #[test]
  fn test_lammps_box() {
      let box1 = "ITEM: BOX BOUNDS pp pp pp
  -0.195983 11.329
  -0.195983 11.329
  -0.195983 11.329";

      // results from ovito
      let cell_vector1 = [11.525, 0.0, 0.0];
      let cell_vector2 = [0.0, 11.525, 0.0];
      let cell_vector3 = [0.0, 0.0, 11.525];
      let cell_origin  = [-0.195983, -0.195983, -0.195983];

      let (vts, origin) = get_lammps_dump_box(&box1).unwrap();

      assert_relative_eq!(vts[0][0], cell_vector1[0] as f64, epsilon=1.0e-4);
      assert_relative_eq!(vts[1][1], cell_vector2[1] as f64, epsilon=1.0e-4);
      assert_relative_eq!(vts[2][2], cell_vector3[2] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[0], cell_origin[0] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[1], cell_origin[1] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[2], cell_origin[2] as f64, epsilon=1.0e-4);

      let box2 = "ITEM: BOX BOUNDS xy xz yz pp pp pp
  -0.08189 15.3282 -0.045807
  0.072939 15.5755 0
  0.001924 17.4877 0";

      // results from ovito
      let cell_vector1 = [15.3643, 0.0, 0.0];
      let cell_vector2 = [-0.045807, 15.5026, 0.0];
      let cell_vector3 = [0.0, 0.0, 17.4858];
      let cell_origin  = [-0.036083, 0.072939, 0.001924];

      let (vts, origin) = get_lammps_dump_box(&box2).unwrap();
      assert_relative_eq!(vts[0][0], cell_vector1[0] as f64, epsilon=1.0e-4);
      assert_relative_eq!(vts[1][0], cell_vector2[0] as f64, epsilon=1.0e-4);
      assert_relative_eq!(vts[1][1], cell_vector2[1] as f64, epsilon=1.0e-4);
      assert_relative_eq!(vts[2][2], cell_vector3[2] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[0], cell_origin[0] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[1], cell_origin[1] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[2], cell_origin[2] as f64, epsilon=1.0e-4);

      let box3 = "ITEM: BOX BOUNDS pp pp ff
  0.0000000000000000e+00 2.2931000000000001e+01
  0.0000000000000000e+00 2.2931000000000001e+01
  -1.0000000000000000e+00 5.0497999999999998e+01
  ";
      let cell_vector1 = [22.931, 0.0, 0.0];
      let cell_vector2 = [0.0, 22.931, 0.0];
      let cell_vector3 = [0.0, 0.0, 51.498];
      let cell_origin = [0.0, 0.0, -1.0];
      let (vts, origin) = get_lammps_dump_box(&box3).unwrap();
      assert_relative_eq!(vts[0][0], cell_vector1[0] as f64, epsilon=1.0e-4);
      assert_relative_eq!(vts[1][1], cell_vector2[1] as f64, epsilon=1.0e-4);
      assert_relative_eq!(vts[2][2], cell_vector3[2] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[0], cell_origin[0] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[1], cell_origin[1] as f64, epsilon=1.0e-4);
      assert_relative_eq!(origin[2], cell_origin[2] as f64, epsilon=1.0e-4);
  }
#+end_src
***** lammps dump atoms
读入原子坐标信息
****** src
#+name: dd0f9789-eb7f-492a-aa0d-24a76d346f76
#+begin_src rust
  fn get_lammps_dump_positions(txt: &str, natoms: usize) -> Result<HashMap<usize, [f64; 3]>, Box<Error>>{
      let mut lines_iter = txt.lines();
      if let Some(line) = lines_iter.next() {
          assert!(line.starts_with("ITEM: ATOMS id type x y z"));
      } else {
          Err("failed to read atoms header.")?;
      }

      let mut positions: HashMap<usize, [f64; 3]> = HashMap::new();
      for _ in 0..natoms {
          if let Some(line) = lines_iter.next() {
              let mut attrs:Vec<_> = line.split_whitespace().collect();
              assert!(attrs.len() >= 5, line.to_string());
              let index:usize = attrs[0].parse().unwrap();
              let x:f64 = attrs[2].parse().unwrap();
              let y:f64 = attrs[3].parse().unwrap();
              let z:f64 = attrs[4].parse().unwrap();
              positions.insert(index, [x, y, z]);
          } else {
              Err("atom records are incomplete")?;
          }
      }

      Ok(positions)
  }
#+end_src

****** tests
#+name: afe1d362-438a-4e03-939d-50e9eaac21e1
#+begin_src rust
  #[test]
  fn test_parse_dump_positions() {
      let txt = "ITEM: ATOMS id type x y z
  1 1 3.77622 3.9054 0.009267
  2 1 3.77622 3.9054 2.90503
  3 1 1.89072 1.66683 4.37145
  4 1 4.97252 1.29462 4.37145
  5 2 4.73984 2.09641 0.131493";

      let natoms = 5_usize;
      let positions = get_lammps_dump_positions(&txt, natoms).unwrap();
      assert_relative_eq!(3.77622, &positions[&1_usize][0]);
      assert_relative_eq!(0.131493, &positions[&5_usize][2]);
  }
#+end_src

**** simplified bonds file
解释reaxa生成的精减版文件.
***** on file basis
#+name: 8497df51-3eb3-41fc-a87d-c1688c94c29f
#+begin_src rust
  fn get_connectivity_from_terse_bonds_file(
      path: &Path,
      target_timestep: usize) -> Result<HashMap<usize, Vec<usize>>, Box<Error>>
  {
      let fp = File::open(path)?;
      let mut reader = BufReader::new(fp);

      // parse bonds
      let mut neighbors: HashMap<usize, Vec<usize>> = HashMap::new();

      let mut timestep = 0;
      let mut natoms = 0;
      let mut buf = String::new();
      loop {
          // 0. sanity check and get current timestep
          buf.clear();
          let nb = reader.read_line(&mut buf)?;
          if nb <= 0 {
              eprintln!("reached the end of the file: {}", path.display());
              break;
          }

          let label = "# Timestep";
          timestep = get_int_data_from_comment_line(&buf, &label)?;
          eprintln!("{:?}", timestep);

          // 1. get natoms
          buf.clear();
          let nb = reader.read_line(&mut buf)?;
          if nb <= 0 {
              Err("Expect more lines: failed to read number of atoms!")?;
          }
          let label = "# Number of particles";
          natoms = get_int_data_from_comment_line(&buf, &label)?;

          // 2. read atom records
          buf.clear();
          if timestep < target_timestep {
              for _ in 0..natoms {
                  let nb = reader.read_line(&mut buf)?;
                  if nb <= 0 {
                      Err("Expect more lines: failed to read all atom records!")?;
                  }
              }
          } else if timestep == target_timestep {
              for _ in 0..natoms {
                  let nb = reader.read_line(&mut buf)?;
                  if nb <= 0 {
                      Err("Expect more lines: failed to read all atom records!")?;
                  }
              }
              neighbors = get_connectivity_from_terse_bonds_file_frame(&buf, natoms)?;
              // ignore other parts
              break;
          } else {
              let msg = format!("Requested timestep {} not found in {}", target_timestep, path.display());
              Err(msg)?;
          }
      }

      Ok(neighbors)
  }
#+end_src

#+name: 1cb4fcf1-d093-41ce-a011-f88a95c9bf7b
#+begin_src rust
  fn parse_terse_bonds_file (path: &Path, symbols: &HashMap<usize, String>)
                             -> Result<Vec<Frame>, Box<Error>>
  {
      // create file handler and a buffle reader
      let fp = File::open(path)?;
      let mut reader = BufReader::new(fp);
      let mut lines_iter = reader.lines().peekable();

      // parse data
      let mut timestep = 0;
      let mut natoms = 0;
      let mut frames = Vec::new();
      loop {
          if lines_iter.peek().is_none() {
              eprintln!("reached the end of the file: {}", path.display());
              break;
          }

          // process a single frame
          let frame = parse_terse_bonds_file_single_frame(&mut lines_iter, &symbols)?;
          eprintln!("timestep {:}, done.", frame.timestep);
          eprintln!("fragments {:?}", frame.fragments);
          // // for test
          // if frame.timestep > 5000_usize {
          //     break;
          // }
          frames.push(frame);
      }

      Ok(frames)
  }
#+end_src

***** on frame basis
读入不同原子对应的电荷及connectivity.
简化版中:
- 以行数来定原子index.
- 第一列为浮点数, 对应partial charge
- 其后几列为与当前原子直接成键的所有原子对应的编号数据. 该数据为键连原子编号与当
  前原子编号之差, 即index - current

#+name: dd3a4020-2ed5-4c62-a6f7-1d80e0fc6198
#+begin_src rust
  fn get_connectivity_from_terse_bonds_file_frame(
      txt: &str,
      natoms: usize) -> Result<HashMap<usize, Vec<usize>>, Box<Error>>
  {
      let mut neighbors = HashMap::new();

      let mut lines_iter = txt.lines();

      for n in 1..natoms+1 {
          if let Some(line) = lines_iter.next() {
              let (charge, nns) = parse_terse_bonds_file_single_line(&line);
              let mut connected = vec![];
              for x in nns {
                  connected.push(x+n);
              }
              neighbors.insert(n, connected);
          } else {
              Err("Atom data is incomplete.")?;
          }
      }

      Ok(neighbors)
  }
#+end_src

#+name: b88e850d-3754-49fe-a0a6-cdf0ba8e2169
#+begin_src rust
  #[test]
  fn test_get_connectivity_from_terse_bonds_frame() {
      let txt = "0.007 8 9 16 896 1017 1016 905 904 120 121 1 112 128
  0.008 128 112 120 121 1 1016 904 896 16 8 1017 905 9
  0.009 112 120 128 896 1016 1017 904 905 121 1 8 16 9
  0.008 120 121 112 1017 1016 905 904 896 8 9 128 16 1
  0.008 896 1017 1016 1 112 904 120 8 905 16 128 121 9";

      let neighbors = get_connectivity_from_terse_bonds_file_frame(&txt, 5_usize).unwrap();
      assert_eq!(neighbors.len(), 5);

      let connected = neighbors.get(&1).unwrap();
      assert_eq!(connected.len(), 13);
      assert_eq!(connected[0], 9);
      assert_eq!(connected[1], 10);
  }
#+end_src

#+name: 5f005858-636b-4d77-aca5-e6be1baca10a
#+begin_src rust
  fn parse_terse_bonds_file_single_frame<I> (
      lines_iter: &mut I,
      symbols: &HashMap<usize, String>) -> Result<Frame, Box<Error>>
      where I: Iterator<Item=io::Result<String>>,
  {
      // 1. read current timestep
      let mut timestep = 0;
      let label = "# Timestep";
      if let Some(line) = lines_iter.next() {
          let line = line?;
          timestep = get_int_data_from_comment_line(&line, &label)?;
      } else {
          Err("Failed to read timestep!")?;
      }

      // 2. read number of atoms
      let mut natoms = 0;
          let label = "# Number of particles";
      if let Some(line) = lines_iter.next() {
          let line = line?;
          natoms = get_int_data_from_comment_line(&line, &label)?;
      } else {
          Err("Failed to read number of atoms!")?;
      }

      // 3. read connectivity for each atom
      let mut atoms = Vec::new();
      assert!(natoms > 0);
      for n in 1..natoms+1 {
          let mut data = AtomData::new();
          if let Some(line) = lines_iter.next() {
              let line = line?;
              let (charge, neighbors) = parse_terse_bonds_file_single_line(&line);
              data.index = n;
              data.charge = charge;
              data.symbol = symbols.get(&data.index).unwrap().to_string();
              for x in neighbors {
                  data.neighbors.push(x+n);
              }
              atoms.push(data);
          } else {
              Err("Atom data is incomplete.")?;
          }
      }

      assert!(atoms.len() == natoms);

      // 4. create frame
      let mut frame = Frame::new();
      frame.timestep = timestep;
      let fragments = fragments_from_atoms(&atoms);
      frame.fragments = fragments;

      Ok(frame)
  }
#+end_src

***** on line basis
#+name: 39637608-12b2-4724-ac38-cfc5d4f9c990
#+begin_src rust
  fn parse_terse_bonds_file_single_line(line: &str) -> (f64, Vec<usize>) {
      let mut attrs = line.split_whitespace();
      let first = attrs.nth(0).unwrap();
      let charge:f64 = first.parse().unwrap();
      let neighbors:Vec<usize> = attrs.map(|x| x.parse::<usize>().unwrap()).collect();

      (charge, neighbors)
  }
#+end_src

#+name: b0d25b51-fbb3-460a-882f-3cdb7c6f6619
#+begin_src rust
  #[test]
  fn test_parse_terse_bonds_line() {
      let s = "0.007 8 9 16 896 1017 1016 905 904 120 121 1 112 128";
      let (charge, neighbors) = parse_terse_bonds_file_single_line(&s);
      assert_eq!(0.007, charge);
      assert_eq!(13, neighbors.len());
      assert_eq!(8, neighbors[0]);
  }
#+end_src

**** TODO bonds file
从bonds文件读入不同timestep时对应的键连信息.

注意: 该文件中的给出的原子类型可能与data文件不同(测试文件的问题?). 应以data文件
中的为准.
***** on file basis
读入bonds文件
#+name: ae4768b5-576f-461b-8186-7bb8b589216b
#+begin_src rust :tangle no
  fn parse_lammps_bonds_file(file: File,
                             natoms: &usize,
                             mapping_symbols: &HashMap<String, String>)
                             -> Result<String, io::Error>
  {
      let mut reader = BufReader::new(file);
      let mut lines_iter = reader.lines().peekable();

      loop {
          if lines_iter.peek().is_none() {
              println!("reached the end of the file.");
              break;
          }

          parse_lammps_bonds_single_snapshot(&mut lines_iter, &natoms, &mapping_symbols);
          if let Some(line) = lines_iter.next() {
              println!("{:?}", line);
          } else {
              println!("Warning: missing final blank comment.");
              break;
          }
      }

      Ok("Good".to_string())
  }
#+end_src

***** on frame basis
读入单个snapshot
****** 各个小的功能块, 方便测试.
#+name: 772f2307-4bde-47b4-b839-435dabaf5f1a
#+begin_src rust
  fn get_int_data_from_comment_line(line: &str, prefix: &str) -> Result<usize, String> {
      if line.starts_with(prefix) {
          let s = line[prefix.len()..].trim().parse::<usize>();
          match s {
              Ok(v) => return Ok(v),
              Err(why) => return Err(format!("{:?}", why)),
          }
      } else {
          let msg = format!("Failed to get value {} for current frame: {}", prefix, line);
          Err(msg)
      }
  }

  #[test]
  fn test_get_int_data_from_comment_line() {
      // get timestep
      let r = get_int_data_from_comment_line("# Timestep 10", "# Timestep");
      assert_eq!(r, Ok(10));
      // get number of atoms
      let r = get_int_data_from_comment_line("# Number of particles 684", "# Number of particles");
      assert_eq!(r, Ok(684));

      let r = get_int_data_from_comment_line("# Timestep 0.0", "# Timestep");
      assert!(r.is_err());
      let r = get_int_data_from_comment_line("12 22\n", "# Timestep");
      assert!(r.is_err());
  }

  // fn get_atom_data_from_line(line: &str) -> Result<(AtomData, &[usize]), String> {
  fn get_atom_data_from_line(line: &str) -> Result<AtomData, String> {
      let mut data = AtomData::new();

      let error = format!("Failed to parse atom data from: {}", line);

      // 1. get index
      let mut attrs = line.split_whitespace();
      if let Some(v) = attrs.next() {
          match v.parse::<usize>() {
              Ok(v) => {
                  data.index = v;
              },
              Err(why) => {
                  return Err(format!("{:?}", why));
              },
          }
      } else {
          return Err(error);
      }

      // 2. get particle type
      if let Some(v) = attrs.next() {
          data.symbol = v.to_string();
      } else {
          return Err("failed to read particle type.".to_string());
      }

      // 3. get number of neighbors
      let mut nneighbors = 0;
      if let Some(v) = attrs.next() {
          match v.parse::<usize>() {
              Ok(v) => {
                  nneighbors = v;
              },
              Err(why) => {
                  return Err(format!("{:?}", why));
              },
          }
      } else {
          return Err("failed to read number of neighbors.".to_string());
      }

      // 4. get neighbors
      // let mut neighbors = vec![];
      for _ in 0..nneighbors {
          if let Some(v) = attrs.next() {
              match v.parse::<usize>() {
                  Ok(v) => {
                      // neighbors.push(v);
                      data.neighbors.push(v);
                  },
                  Err(why) => {
                      return Err(format!("{:?}", why));
                  },
              }
          } else {
              return Err(error);
          }
      }

      Ok(data)
  }

  #[test]
  fn test_get_atom_data_from_line() {
      let line = " 121 3 2 301 28 0         0.978         0.978         1.956         2.000        -0.736 ";
      let r = get_atom_data_from_line(&line);
      assert!(r.is_ok());
      // let (data, _) = r.unwrap();
      let data = r.unwrap();
      assert!(data.index == 121);
      assert!(data.symbol == "3");
  }

#+end_src

****** 最外层控制.
#+name: a0057eaf-1b2f-4b5d-a261-5e44f026a915
#+begin_src rust :tangle no
  use std::iter::Peekable;

  fn parse_lammps_bonds_single_snapshot<I>(lines_iter: &mut I,
                                           natoms: &usize,
                                           mapping_symbols: &HashMap<String, String>)
                                           -> Result<(), String>
      where I: Iterator<Item=io::Result<String>>,
  {
      let mut timestep = 0 as usize;

      // 1. read in meta data from comments
      // expected => Some(Ok("# Timestep 0 "))
      for n in 0..7 {
          let line = lines_iter.next().unwrap().unwrap();
          assert!(line.starts_with("# "), line);
          match n {
              0 => {
                  timestep = get_int_data_from_comment_line(&line, "# Timestep").unwrap();
                  println!("timestep = {:?}", timestep);
              },
              2 => {
                  let na = get_int_data_from_comment_line(&line, "# Number of particles").unwrap();
                  if na != *natoms {
                      let msg = format!("number of atoms: {} != {}", na, *natoms);
                      return Err(msg);
                  }
              },
              _ => {;}
          }
      }

      // 2. read atom data
      // 2.1 setup graph
      let mut gr = Graph::new_undirected();
      for _ in 0..*natoms {
          gr.add_node("X".to_string());
      }

      // 2.2 assign atom symbols and bonds
      for _ in 0..*natoms {
          if let Some(line) = lines_iter.next() {
              let line = line.unwrap();
              let data = get_atom_data_from_line(&line).unwrap();
              let n1 = NodeIndex::new(&data.index - 1);

              // add bonds
              for i in &data.neighbors {
                  let n2 = NodeIndex::new(i-1);
                  gr.update_edge(n1, n2, 1);
              }
              // update atom symbol
              let nw = gr.node_weight_mut(n1).unwrap();
              ,*nw = data.symbol;
          } else {
              let msg = format!("atom data is incomplete\ntimestep = {}", timestep);
              return Err(msg);
          }
      }
      show_fragments(&gr, &mapping_symbols);
      Ok(())
  }
#+end_src

** tests                                                            :ATTACH:
这个目录下的代码用于集成测试.
*** test_graph.rs
:PROPERTIES:
:header-args: :tangle reaxb/tests/test_graph.rs
:ID:       176c677d-c9cb-4f4f-b20e-7e68f6ee680f
:Attachments: screenshot_2018-02-13_16-59-08.png
:END:

参考图像:
#+DOWNLOADED: @ 2018-02-13 16:59:09
#+caption: CH4和H2O
#+name: fig:ea828016
#+attr_org: :width 400
#+attr_odt: :width 5
[[file:data/17/6c677d-c9cb-4f4f-b20e-7e68f6ee680f/screenshot_2018-02-13_16-59-08.png]]

#+name: 3ac4ebc7-6b99-4984-8571-f0cc7ab27990
#+begin_src rust
  extern crate petgraph;

  use std::collections::HashSet;

  use petgraph::prelude::*;
  use petgraph as pg;
  use petgraph::graph::node_index as n;

  #[test]
  fn test_get_connected_components() {
      let mut graph = Graph::new_undirected();

      // weight
      let w = 0;

      let mut v = Vec::new();

      // Add 8 vertices to G
      for i in 0..8 {
          v.push(graph.add_node(i));
      }

      // create bonds for CH4
      for i in 1..5 {
          graph.add_edge(v[0], v[i], w);
      }

      graph.add_edge(v[5], v[6], w);
      graph.add_edge(v[5], v[7], w);

      let ncc = pg::algo::connected_components(&graph);
      assert_eq!(2, ncc);

      for x in pg::algo::kosaraju_scc(&graph) {
          println!("{:?}", x);
      }

      // store connected components
      let mut ccs1 = HashSet::new();
      ccs1.insert(v[0]);
      ccs1.insert(v[1]);
      ccs1.insert(v[2]);
      ccs1.insert(v[3]);
      ccs1.insert(v[4]);

      let mut ccs2 = HashSet::new();
      ccs2.insert(v[5]);
      ccs2.insert(v[6]);
      ccs2.insert(v[7]);
  }

#+end_src

* src
** cmdline
:PROPERTIES:
:header-args: :tangle src/cmdline/main.rs
:END:

#+name: d0e077ec-1065-4135-a81d-db3d27ffd37e
#+begin_src rust
  extern crate clap;

  use std::env;
  use clap::{App, Arg};
  use std::io;
  use std::io::prelude::*;
  use std::fs::File;
  use std::io::BufReader;
  use std::cmp::Eq;


  #[derive (Default, Debug, PartialEq, PartialOrd, Clone)]
  /// Point3D, a point / position within 3D space
  pub struct Point3D {
      pub x: f64,
      pub y: f64,
      pub z: f64
  }

  impl Point3D {
      pub fn new(x: f64, y: f64, z: f64) -> Self {
          Point3D {x: x, y: y, z: z}
      }
  }

  impl Eq for Point3D {}

  #[test]
  fn point_3d_test() {
      let p = Point3D::new(0., 0., 0.);
      assert!(p.x == 0.);
      assert!(p.y == 0.);
      assert!(p.z == 0.);

      let p2 = Point3D::new(0., 0., 0.);
      assert!(p == p2);
  }


  fn readfile(filename: &str){
      let mut f = File::open(filename).expect("cannot open file");
      let reader = BufReader::new(f);
  }

  fn main() {
      // let args: Vec<String> = env::args().collect();
      // println!("{:?}", args);
      // println!("{:?}", args.len());
      let matches = App::new("MyApp")
          .version("0.1")
          .author("Wenping Guo <winpng@gmail.com>")
          .about("Does awesome things")
          .arg(
              Arg::with_name("debug")
                  .help("debug switch")
                  .long("debug")
                  .multiple(true)
                  .short("d")
          )
          .arg(
              Arg::with_name("input")
                  .help("set input file name")
                  .index(1)
          )
          .get_matches();

      match matches.occurrences_of("debug") {
          0 => println!("Debug mode is off"),
          1 => println!("Debug mode is kind of on"),
          2 => println!("Debug mode is on"),
          3 | _ => println!("Don't be crazy"),
      }

      if let Some(o) = matches.value_of("input") {
          println!("Value for input: {}", o);
          readfile(o);
      }
  }
#+end_src

** main
:PROPERTIES:
:header-args: :tangle src/main.rs
:END:
*** globals
#+name: f8c09544-ff6f-4589-9c06-d83d9b36e3ab
#+begin_src rust
  // extern crate base64;
  #[macro_use]
  extern crate nom;
  extern crate petgraph;
#+end_src

*** basis
#+name: b08803c2-e9b1-4542-9574-b8c467d527b1
#+BEGIN_SRC rust
  fn sqrt(x: f64) -> f64 {
      let mut y:f64 = if x < 5. {5.} else {10.};
      loop {
          y += 1.;
          if y > 15. {
              break;
          }
      }
      y.sqrt()
  }

  fn test_tuple() -> (i32, i32){
      let t = (1, 2);
      let (a, b) = t;
      let i = 1;
      t
  }

  fn test_array() {
      let arr: [f64; 100] = [0.1; 100];
      println!("{:?}, {}", arr[10], arr.len());

      let mut arr = [1, 5, 3, 2];
      arr.sort();
      println!("{:?}", arr);
  }

  fn test_vector() {
      let mut v = vec![1, 2, 0, 5];
      v.insert(0, 13);
      assert_eq!(v, [13, 1, 2, 0, 5]);
      assert_eq!(v[0], 13);
      let v:Vec<i32> = (0..5).collect();
      println!("{:?}", v);
  }

  fn test_slice() -> i32 {
      let arr = [1, 2, 3, 4];
      let slice = &arr;
      let last = slice.get(3);
      println!("last = {}", last.unwrap());
      // println!("last = {}", arr[5]);
      ,*last.unwrap()
  }

  fn test_string () {
      // let mut s = "good to go to do".to_string();
      // s.push('好');
      // let x = s.pop();
      // println!("x={:?}, s={:?}", x.unwrap(), s);
      // println!("{}", "y̆".len());
      // println!("{:?}", "y̆".chars());
      let mut s = "good";
      println!("{:?}", s);
  }

  fn test_hashmap() {
      use std::collections::HashMap;
      let mut scores = HashMap::new();
      scores.insert("Blue", 10);
      // scores.insert("Blue", 20.); adding float will fail
      println!("{:?}", scores);
  }

#+END_SRC

*** nom
#+name: 76f3c475-acd4-492d-b4fc-50da7265bfd9
#+begin_src rust
  fn test_nom(){
      named!(get_greeting<&str,&str>,
             take_s!(2)
      );

      let res = get_greeting("hi there");
      println!("{:?}",res);
  }
#+end_src

*** atoms
定义最简单的原子结构信息.
#+name: 1f84ef01-7ddb-4295-8521-c29ad7d7e059
#+begin_src rust
  use std::hash::{Hash, Hasher};
  use std::cmp::Ordering;

  #[derive (Default, Debug, Clone, Copy)]
  /// simple atom data structure
  pub struct Atom {
      pub index: u64,
      pub symbol: &'static str,
  }

  impl PartialEq for Atom {
      fn eq(&self, other: &Atom) -> bool {
          self.index == other.index
      }
  }

  impl Eq for Atom {}

  impl Hash for Atom {
      fn hash<H: Hasher>(&self, state: &mut H) {
          self.index.hash(state);
      }
  }

  impl Ord for Atom {
      fn cmp(&self, other: &Atom) -> Ordering {
          self.index.cmp(&other.index)
      }
  }

  impl PartialOrd for Atom {
      fn partial_cmp(&self, other: &Atom) -> Option<Ordering> {
          Some(self.cmp(other))
      }
  }

  #[test]
  fn test_atom() {
      let a = Atom{
          index: 1,
          symbol: "H",
      };

      let b = Atom {
          index: 2,
          symbol: "H",

      };
      let mut c = Atom {
          index: 1,
          symbol: "H",
      };

      assert!(a != b);
      assert!(a == c);

      assert!(a.index == 1);
      assert!(a.symbol == "H");

      c.symbol = "C";
      assert!(c.symbol == "C");
  }
#+end_src

实现从元素符号列表到分子式.
#+name: 27fa4abe-d98c-4dd4-8695-e4b4f807cabc
#+begin_src rust
  use std::collections::HashMap;

  // fn get_reduced_formula<'a, I>(symbols: I) -> Option<&'static str>
  //     where I: Iterator<Item=&'static str>,
  // {
  //     for x in symbols {
  //         println!("{:?}", x);
  //     }

  //     Some("C2H4")
  // }

  fn get_reduced_formula(symbols: &[&str]) -> String {
      let mut counts = HashMap::new();
      for x in symbols {
          let c = counts.entry(x).or_insert(0);
          ,*c += 1;
      }

      let mut syms: Vec<String> = Vec::new();
      let mut to_append = String::new();

      for (k, v) in counts {
          let reduced = format!("{}{}", k, v);
          if *k == "C" {
              syms.insert(0, reduced);
          } else if *k == "H" {
              to_append = reduced;
          } else {
              syms.push(reduced);
          }
      }
      syms.push(to_append);
      let formula = syms.join("");
      formula
  }

  #[test]
  fn test_formula() {
      let symbols   = vec!["C", "H", "C", "H", "H", "H"];
      let formula = get_reduced_formula(&symbols);
      assert!(formula == "C2H4".to_string());
      let symbols   = vec!["C", "H", "C", "H", "H", "O", "H", "O"];
      let formula = get_reduced_formula(&symbols);
      println!("{:?}", formula);
      assert!(formula == "C2O2H4".to_string());
  }
#+end_src

*** petgraph
#+name: deb8ea39-2a90-4db1-987b-121d98047d53
#+begin_src rust
  fn test_petgraph() {
      use petgraph as pg;
      use std::collections::HashMap;

      let mut G = pg::Graph::new_undirected();
      let aa = [0; 4];
      let bb = [1; 4];
      let x = G.add_node(aa);
      let y = G.add_node(bb);
      let e = G.add_edge(x, y, (1, 1));
      let f = G.add_edge(x, y, (2, 2));
      println!("{:?}", &G[x]);
      println!("{:?}", &G[y]);
      println!("{:?}", e);
      println!("{:?}", &G[e]);
      println!("{:?}", f);
      println!("{:?}", &G[f]);
  }

  fn test_petgraph_graphmap() {
      use petgraph as pg;
      use petgraph::prelude::*;
      let mut G = UnGraphMap::new();

      let a = Atom{
          index: 1,
          symbol: "H",
      };

      let b = Atom{
          index:2,
          symbol:"H",
      };

      println!("{:?}, {:?}", a, b);
      G.add_node(a);
      G.add_node(b);
      G.add_edge(a, b, 1);
      println!("{:?}", &G);
      println!("{:?}", &G[(a, b)]);
  }
#+end_src

*** cmdline
#+name: 82c97bbd-b1b7-492e-8aa2-31271b45b049
#+begin_src rust
  fn main() {
      // let bytes = base64::decode("aGVsbG8gd29ybGQ=").unwrap();
      // println!("{:?}", bytes);

      // println!("this is a hello {}", "world");
      // println!("{}", 12);

      // let mut sum = 0.;
      // for i in 0..5 {
      //     sum += i as f64;
      //     println!("loop: {}, sum = {}", i, sum);
      // }

      // let mut v = sqrt(sum);
      // println!("{}", v);

      test_petgraph_graphmap();
  }
#+end_src

* References
- [[https://rust-lang-nursery.github.io/rust-cookbook/basics.html][Rust Cookbook]]
- [[http://stevedonovan.github.io/rust-gentle-intro/readme.html][Introduction - A Gentle Introduction to Rust]]
- [[https://rustbyexample.com/][Introduction - Rust By Example]]
- [[https://learnxinyminutes.com/docs/rust/][Learn rust in Y Minutes]]

* Local variables
# Local Variables:
# mode: org
# end:

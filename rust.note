#+TITLE: Learn Rust
#+SETUPFILE: ~/Notes/common.org
#+SETUPFILE: ~/Notes/latex.org
#+SETUPFILE: ~/Notes/coding.org

* Memo [0/3]
** TODO [2017-12-30 Sat] 完成[[http://exercism.io/languages/rust/exercises][exercism.io]]上的练习
** TODO [2017-12-30 Sat] 使用rust来完成之前写的lindermann指数计算程序
** [2017-12-26 Tue] rust基础练习3 基本数据结构
*** tuple
: tuples like (1, true)
- tuple中的数据可以是不同类型的.
- 通过tuple, 函数可以返回多个数值.

tuple输出时:
: println("{:?}", (1, 2));

tuple可以通过位置来指认:
#+name: 7db31524-8474-431d-8e3c-279dd552c4e3
#+begin_src rust
  let t = (1, 2);

  print!("{}, {}", t.0, t.1);
#+end_src

可以像python一样, 可以把tuple展开给多个变量:
#+name: efd8cd2d-26a7-47da-a4ab-841a2f6a1396
#+begin_src rust
  let t = (1, 2, 3);
  let (a, b, c) = t;
#+end_src
注意左侧的变量要用tuple的形式括起来, 否则会报错. 这也python不同.

注意tuple引用内部成员时不能使用变量, 也不能像python的那样来取值. 下面的语句是错的:
: let t = (12, 2, 'a');
: let i = 1;
: println! ("{}", t.i);  // 错误
: println! ("{}", t[0]); // 错误

只有一个成员的tuple, 后面的逗号不能省略:
: let t = (12,);

无成员类型:
: let t = ();

函数无返回值时, 默认返回(), 相当于python中的None?

*** arrays, slices
: arrays like [1, 2, 3]
rust中的array和C里的静态数组类似, 成员类型要一致, 运行时不可增删.
#+name: 263760d4-6182-4794-8e27-704b2aa61a31
#+begin_src rust
  let arr = [1, 2, 5, 9, 10];
  println!("{}", arr[0], array[2]);
#+end_src
如何访问数组成员越界, rust在编译时就会报错.

成员函数:
: arr.len();
: arr.sort();

数组声明时, 要指明成员数值类型及成员数:
: let arr: [i32; 5] = [1, 2, 3, 4, 6];
注意中间用的是分号.
: let arr: [i32; 500] = [12; 500];
注意右侧的值为500个12.

如果要使用range来提取多个数值, 需要取址, 用slice:
: &arr[1..5]

二维数组:
#+name: ec1673bf-357a-475c-bb95-ff63fe463bc2
#+begin_src rust
  let arr = [[1, 5], [2, 4]];
  println!("{:?}", arr[0][1]);
#+end_src

slice在运行期才能知道数组的大小, 为了避免panic, 可以用slice.get方法
#+name: f9bd3ee7-0cce-4adc-a0da-cf3a440101b4
#+begin_src rust
  let arr = [1, 2, 3, 4];
  let slice = &arr;
  let last = slice.get(5);
#+end_src
这与python中的dict.get类似. slice访问如果越界, 会返回一个特殊的数据结构Option,
值为None.

Option对象可用函数:
: last.is_some();
: last.is_none();
如果opt有值, 可以提出来:
: last.unwrap();
如果opt是None, unwrap的话运行时会panic.

更便捷的方式是使用unwrap_or
: last.unwrap_or(&-1)
注意参数用&取址.

注意last.unwrap()取出的数据为reference, 不是实在的数据. 记得根据需求解引:
: *last.unwrap()
*** vector
vector是动态数组, 同array一样, 成员类型要一致.

声明变量:
: let v = vec![2, 3, 1, 5];
或者:
: let v = Vec::new();
: v.push(2);
: ...

可以从iterator初始化:
: let v:Vec<i32> = (0..5).collect();
注意v要指明类型.

添加元素:
: v.push(1);

插入元素:
: v.insert(1, 'a');

删除元素:
: v.remove(1);

*** string
双引号中的为literal string. 中间可以包括硬回车或转义字符.
#+name: c0f6ce7f-deac-4321-9c14-4312a9518957
#+begin_src rust
  let s = "good to go\n";

  let s = "good
  to go";

  // s = good togo
  let s = "good to\
           go";
#+end_src
字串中可以使用~\~来续行.

raw string:
#+name: 3de9f418-5b32-42b6-bf5c-6285b458ad7c
#+begin_src rust
  // s = "\n\n"
  let s = r"\n\n";
#+end_src

使用format! macro来生成格式化字符串.
#+name: 21f9c2a1-d351-468e-a414-c37f018903df
#+begin_src rust
  let s = format!("{}", 2.2);
#+end_src

String可用的函数:
: s.len();
与python不同, rust中的string不能index, 比如s[0], 但可以slice:
#+name: 7a55e292-1387-4cdc-8f05-14e9ed00c888
#+begin_src rust
  let s = "abcdef";
  let subs = &s[1..2]
#+end_src

合并字串
#+name: 425fe069-3e10-417a-8929-2551b7417db2
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.concat();
#+end_src

像python中的str.join
#+name: f91f9154-1da8-4788-a969-dc72a2e281c1
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.join("\n");
#+end_src

其它:
contains, replace, trim, split

*** TODO structs
这个像namedtuple, C里的结构体. 通名称来指认内部成员更方便些.

** [2017-12-21 Thu] rust基础练习2 control flow
#+name: 5fde93b8-94a6-4341-9db8-f3625238dfc5
#+BEGIN_SRC rust
  if (a < b) {
      println!("{}", 1);
  } else {
      println!("{}", 2);
  }
#+END_SRC

如果是多个条件:
: else if

注意if等判断语句后跟bool类型. rust不会像python做隐式类型转换. 比如下面的语句会报错:
#+name: be800e54-711b-4393-aefb-811c41ba2b7a
#+begin_src rust
  let r = 1;
  if r {...};
#+end_src

也可以像python写成单行表达式
#+name: 632a594b-c4a8-48db-ab4d-f176d44954b2
#+BEGIN_SRC rust
  let y:f64 = if a < 4. {1.} else {2.}
#+END_SRC
此时要注意, else前后的返回值类型要一致, 否则会报错.

循环结构可以用loop, while, for. break/continue同样可用.

对于多层循环, rust中可以使用标签, 然后break到指定位置. 见[[https://rustbyexample.com/flow_control/loop/nested.html][doc]].

rust使用match来实现像C里的switch语句类似的功能.

** [2017-12-20 Wed] rust基础练习1 变量常量类型
常量定义:
: let sum = 0;

变量定义:
: let mut sum = 0;

上面的sum变量被定义为整型, 可以加和整型数据.

如果sum定义为浮点数:
: let mut sum = 0.;
: sum += 1;
自加和整型数1会报错. 需要对1进行显式的类型转换:
: sum += 1 as f64;
或者:
: sum += 1_f64;

如果是变量必须用"as f64"
: sum += i as f64;

rust对数值类型要求很严, 整数除以浮点数会报错
: 12/2.

整数除以整数会得到一个整数:
: 13/6
上面的值为2

常见的数值类型: i32, i64, u32, u64, f32, f64

rust避免做任何假设, 这倒是免掉了C里面的不少坑.


常见数值运算: [[https://doc.rust-lang.org/std/primitive.f64.html][docs]]
: x.abs()
: x.powf(2.)
: x.sqrt()

#+name: dac3cc9f-d575-49e3-a759-49a1f88224e8
#+BEGIN_SRC rust
  for i in 0..5 {
      println!("loop {}", i);
  }
#+END_SRC

loop变量不需要显式定义.

自定义函数:
#+BEGIN_EXAMPLE
fn sqrt(x: f64) -> f64 {
  return x*x;
}
#+END_EXAMPLE
函数返回值以最后一个语句为准, 因此return可以略去(同时去掉最后的分号).

** TODO [2017-12-12 Tue] 使用rust实现之前写的files-coder
** [2017-12-10 Sun] 使用cargo来管理rust程序
: cargo new test1 --bin
: cargo run test1


* cargo
#+name: 7935cdce-84b1-4d22-a63d-7d0a8580a279
#+BEGIN_SRC conf :tangle Cargo.toml
  [package]
  name = "test1"
  version = "0.1.0"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  base64 = "0.8.0"

#+END_SRC

* tests
** reverse string
*** test
#+name: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_src shell :results output
  cd exercism/rust/reverse*
  cargo test
#+end_src

#+RESULTS: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 5 tests
test test_a_capitalized_word ... ignored
test test_a_palindrome ... ignored
test test_a_sentence_with_punctuation ... ignored
test test_a_word ... ignored
test test_empty_string ... ok

test result: ok. 1 passed; 0 failed; 4 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/reverse-string/src/lib.rs
:END:

#+name: 3d017385-a2ca-49af-8494-9b2dd4569f24
#+begin_src rust
  pub fn reverse(s: &str) -> String {
      s.chars().rev().collect::<String>()
  }
#+end_src

* src
** main
:PROPERTIES:
:header-args: :tangle src/main.rs
:END:

#+name: b08803c2-e9b1-4542-9574-b8c467d527b1
#+BEGIN_SRC rust
  // extern crate base64;

  fn sqrt(x: f64) -> f64 {
      let mut y:f64 = if x < 5. {5.} else {10.};
      loop {
          y += 1.;
          if y > 15. {
              break;
          }
      }
      y.sqrt()
  }

  fn test_tuple() -> (i32, i32){
      let t = (1, 2);
      let (a, b) = t;
      let i = 1;
      t
  }

  fn test_array() {
      let arr: [f64; 100] = [0.1; 100];
      println!("{:?}, {}", arr[10], arr.len());

      let mut arr = [1, 5, 3, 2];
      arr.sort();
      println!("{:?}", arr);
  }

  fn test_vector() {
      let mut v = vec![1, 2, 0, 5];
      v.insert(0, 13);
      assert_eq!(v, [13, 1, 2, 0, 5]);
      assert_eq!(v[0], 13);
      let v:Vec<i32> = (0..5).collect();
      println!("{:?}", v);
  }

  fn test_slice() -> i32 {
      let arr = [1, 2, 3, 4];
      let slice = &arr;
      let last = slice.get(3);
      println!("last = {}", last.unwrap());
      // println!("last = {}", arr[5]);
      ,*last.unwrap()
  }

  fn test_string () {
      let s = "good to go to do";
      let bits = vec!["a", "b", "c"];
      let s = bits.join("\n");
      println!("{}", s);
  }

  fn main() {
      // let bytes = base64::decode("aGVsbG8gd29ybGQ=").unwrap();
      // println!("{:?}", bytes);

      println!("this is a hello {}", "world");
      println!("{}", 12);

      let mut sum = 0.;
      for i in 0..5 {
          sum += i as f64;
          println!("loop: {}, sum = {}", i, sum);
      }

      let mut v = sqrt(sum);
      println!("{}", v);
      test_string();
  }
#+END_SRC

* References
- Programming rust
- [[http://stevedonovan.github.io/rust-gentle-intro/readme.html][Introduction - A Gentle Introduction to Rust]]
- [[https://rustbyexample.com/][Introduction - Rust By Example]]
- [[https://learnxinyminutes.com/docs/rust/][Learn rust in Y Minutes]]

* Local variables
# Local Variables:
# mode: org
# end:

#+TITLE: Learn Rust: hack without fear!
#+SETUPFILE: ~/Notes/common.org
#+SETUPFILE: ~/Notes/latex.org
#+SETUPFILE: ~/Notes/coding.org

* Memo [0/5]
** TODO [2018-01-28 Sun] 使用nom解析格式化文件
- [[https://stevedonovan.github.io/rust-gentle-intro/nom-intro.html#parsing-text-with-nom][Parsing with Nom - A Gentle Introduction to Rust]]
- [[http://rust.unhandledexpression.com/nom/][nom - Rust]]

nom的优点:
- 解析单元可自由组合 (parser combinator library)
- 容易调试, 容易集成. 方便实现更复杂的解析逻辑
- 比regex更快.

** [2018-01-19 Fri] 文件读写
- [[https://doc.rust-lang.org/std/fs/struct.File.html][std::fs::File - Rust]]
- [[https://doc.rust-lang.org/std/io/index.html][std::io - Rust]]
- [[https://doc.rust-lang.org/std/io/struct.BufReader.html][std::io::BufReader - Rust]]

** [2018-01-18 Thu] Result和Option类型
Result枚举类型是对所有返回值的完全分类：正常（Ok）或出错（Err）。Option枚举类型
是对所有可选项的完全分类，有值（Some）或无值（None）。

Result和Option经常用于匹配参数返回不同数据上（match）。

Reference
- [[https://doc.rust-lang.org/std/result/][std::result - Rust]]
- [[https://doc.rust-lang.org/std/option/][std::option - Rust]]

** [2018-01-18 Thu] [[https://blog.rust-lang.org/2017/12/21/rust-in-2017.html][Rust in 2017: what we achieved]]
感觉上是python和C的完美结合.

- [[https://github.com/rust-lang-nursery/tempdir][rust-lang-nursery/tempdir: Temporary directory management for Rust]]
- [[https://github.com/rayon-rs/rayon][rayon-rs/rayon: Rayon: A data parallelism library for Rust]]

** TODO [2018-01-17 Wed] 使用log工具
- [[https://github.com/rust-lang-nursery/log][rust-lang-nursery/log: Logging implementation for Rust]]

log将和slog合并: [[https://github.com/rust-lang-nursery/log/issues/149][Structured Logging · Issue #149 · rust-lang-nursery/log]]

** [2018-01-17 Wed] rust基础练习4: 简单命令行界面
可以使用std::env来提取. env::args返回的是Iterator, 其中每个参数都为string类型.

复杂点的可以用[[https://github.com/kbknapp/clap-rs][clap]].

** [2018-01-01 Mon] rust ownership :ATTACH:
:PROPERTIES:
:ID:       dfcf2ff4-7214-483f-8b66-bf76a0372e8a
:Attachments: rust-intro-2018-01-01142409_2018-01-01_14-26-11.png
:END:

#+DOWNLOADED: @ 2018-01-01 14:26:11
#+attr_org: :width 600
#+attr_odt: :width 8
[[file:data/df/cf2ff4-7214-483f-8b66-bf76a0372e8a/rust-intro-2018-01-01142409_2018-01-01_14-26-11.png]]

** TODO [2017-12-30 Sat] 完成[[http://exercism.io/languages/rust/exercises][exercism.io]]上的练习
** TODO [2017-12-30 Sat] 使用rust来完成之前写的lindermann指数计算程序
** [2017-12-26 Tue] rust基础练习3 基本数据结构
*** tuple
: tuples like (1, true)
- tuple中的数据可以是不同类型的.
- 通过tuple, 函数可以返回多个数值.

tuple输出时:
: println("{:?}", (1, 2));

tuple可以通过位置来指认:
#+name: 7db31524-8474-431d-8e3c-279dd552c4e3
#+begin_src rust
  let t = (1, 2);

  print!("{}, {}", t.0, t.1);
#+end_src

可以像python一样, 可以把tuple展开给多个变量:
#+name: efd8cd2d-26a7-47da-a4ab-841a2f6a1396
#+begin_src rust
  let t = (1, 2, 3);
  let (a, b, c) = t;
#+end_src
注意左侧的变量要用tuple的形式括起来, 否则会报错. 这也python不同.

注意tuple引用内部成员时不能使用变量, 也不能像python的那样来取值. 下面的语句是错的:
: let t = (12, 2, 'a');
: let i = 1;
: println! ("{}", t.i);  // 错误
: println! ("{}", t[0]); // 错误

只有一个成员的tuple, 后面的逗号不能省略:
: let t = (12,);

无成员类型:
: let t = ();

函数无返回值时, 默认返回(), 相当于python中的None?

*** arrays, slices
: arrays like [1, 2, 3]
rust中的array和C里的静态数组类似, 成员类型要一致, 运行时不可增删.
#+name: 263760d4-6182-4794-8e27-704b2aa61a31
#+begin_src rust
  let arr = [1, 2, 5, 9, 10];
  println!("{}", arr[0], array[2]);
#+end_src
如何访问数组成员越界, rust在编译时就会报错.

成员函数:
: arr.len();
: arr.sort();

数组声明时, 要指明成员数值类型及成员数:
: let arr: [i32; 5] = [1, 2, 3, 4, 6];
注意中间用的是分号.
: let arr: [i32; 500] = [12; 500];
注意右侧的值为500个12.

如果要使用range来提取多个数值, 需要取址, 用slice:
: &arr[1..5]

二维数组:
#+name: ec1673bf-357a-475c-bb95-ff63fe463bc2
#+begin_src rust
  let arr = [[1, 5], [2, 4]];
  println!("{:?}", arr[0][1]);
#+end_src

slice在运行期才能知道数组的大小, 为了避免panic, 可以用slice.get方法
#+name: f9bd3ee7-0cce-4adc-a0da-cf3a440101b4
#+begin_src rust
  let arr = [1, 2, 3, 4];
  let slice = &arr;
  let last = slice.get(5);
#+end_src
这与python中的dict.get类似. slice访问如果越界, 会返回一个特殊的数据结构Option,
值为None.

Option对象可用函数:
: last.is_some();
: last.is_none();
如果opt有值, 可以提出来:
: last.unwrap();
如果opt是None, unwrap的话运行时会panic.

更便捷的方式是使用unwrap_or
: last.unwrap_or(&-1)
注意参数用&取址.

注意last.unwrap()取出的数据为reference, 不是实在的数据. 记得根据需求解引:
: *last.unwrap()
*** vector
vector是动态数组, 同array一样, 成员类型要一致.

声明变量:
: let v = vec![2, 3, 1, 5];
或者:
: let v = Vec::new();
: v.push(2);
: ...

可以从iterator初始化:
: let v:Vec<i32> = (0..5).collect();
注意v要指明类型.

添加元素:
: v.push(1);

插入元素:
: v.insert(1, 'a');

删除元素:
: v.remove(1);

*** string
**** char
单引号: char
双引号: literal string

**** str, string literal
双引号中的为literal string (&'static str). literal string为静态数据类型, 就像是整型, 浮点型.

中间可以包括硬回车或转义字符.
#+name: c0f6ce7f-deac-4321-9c14-4312a9518957
#+begin_src rust
  let s = "good to go\n";

  let s = "good
  to go";

  // s = good togo
  let s = "good to\
           go";
#+end_src
字串中可以使用~\~来续行.

raw string:
#+name: 3de9f418-5b32-42b6-bf5c-6285b458ad7c
#+begin_src rust
  // s = "\n\n"
  let s = r"\n\n";
#+end_src

lieral string可用的函数:
: s.len();
与python不同, rust中的string不能index, 比如s[0], 但可以slice:
#+name: 7a55e292-1387-4cdc-8f05-14e9ed00c888
#+begin_src rust
  let s = "abcdef";
  let subs = &s[1..2]
#+end_src

**** String
内存动态分配的string.

[[https://doc.rust-lang.org/std/string/struct.String.html][std::string::String - Rust]]

A UTF-8 encoded, growable string

初始化:
: let s = String::new();
: let s = String::from("world");
: let s = "Hello".to_string();

修改字串:
string.push, string.push_str, string.pop, string.remove, string.insert, string.insert_str, string.truncate, string.clear
: s.push('1');
: s.push('好');
: s.push_str("bar");

可以像python一样, 使用"+"来合并字串:
#+name: 9e15f850-01c6-4368-b21e-fe560b347feb
#+begin_src rust
  let mut s = "good to go to do".to_string();
  s.push('d');
  println!("{}", s + "good");
#+end_src

使用format! macro来生成格式化字符串.
#+name: 21f9c2a1-d351-468e-a414-c37f018903df
#+begin_src rust
  let s = format!("{}", 2.2);
#+end_src

合并字串
#+name: 425fe069-3e10-417a-8929-2551b7417db2
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.concat();
#+end_src

像python中的str.join
#+name: f91f9154-1da8-4788-a969-dc72a2e281c1
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.join("\n");
#+end_src

取子串:
: s.chars()

其它:
contains, replace, trim, split

测试:
string.contains, string.starts_with, string.ends_with, string.find

其它:
string.split, string.trim, string.repeat
: assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));

iteration
string.chars

&string: shared reference to string
&str: string slice
*** TODO hash maps
- [[https://doc.rust-lang.org/book/second-edition/ch08-03-hash-maps.html][Hash Maps - Hash Maps - The Rust Programming Language]]

*** TODO structs
这个像namedtuple, C里的结构体. 通名称来指认内部成员更方便些.

** [2017-12-21 Thu] rust基础练习2 control flow
#+name: 5fde93b8-94a6-4341-9db8-f3625238dfc5
#+BEGIN_SRC rust
  if (a < b) {
      println!("{}", 1);
  } else {
      println!("{}", 2);
  }
#+END_SRC

如果是多个条件:
: else if

注意if等判断语句后跟bool类型. rust不会像python做隐式类型转换. 比如下面的语句会报错:
#+name: be800e54-711b-4393-aefb-811c41ba2b7a
#+begin_src rust
  let r = 1;
  if r {...};
#+end_src

也可以像python写成单行表达式
#+name: 632a594b-c4a8-48db-ab4d-f176d44954b2
#+BEGIN_SRC rust
  let y:f64 = if a < 4. {1.} else {2.}
#+END_SRC
此时要注意, else前后的返回值类型要一致, 否则会报错.

循环结构可以用loop, while, for. break/continue同样可用.

对于多层循环, rust中可以使用标签, 然后break到指定位置. 见[[https://rustbyexample.com/flow_control/loop/nested.html][doc]].

rust使用match来实现像C里的switch语句类似的功能.

** [2017-12-20 Wed] rust基础练习1 变量常量类型
常量定义:
: let sum = 0;

变量定义:
: let mut sum = 0;

上面的sum变量被定义为整型, 可以加和整型数据.

如果sum定义为浮点数:
: let mut sum = 0.;
: sum += 1;
自加和整型数1会报错. 需要对1进行显式的类型转换:
: sum += 1 as f64;
或者:
: sum += 1_f64;

如果是变量必须用"as f64"
: sum += i as f64;

rust对数值类型要求很严, 整数除以浮点数会报错
: 12/2.

整数除以整数会得到一个整数:
: 13/6
上面的值为2

常见的数值类型: i32, i64, u32, u64, f32, f64

rust避免做任何假设, 这倒是免掉了C里面的不少坑.


常见数值运算: [[https://doc.rust-lang.org/std/primitive.f64.html][docs]]
: x.abs()
: x.powf(2.)
: x.sqrt()

#+name: dac3cc9f-d575-49e3-a759-49a1f88224e8
#+BEGIN_SRC rust
  for i in 0..5 {
      println!("loop {}", i);
  }
#+END_SRC

loop变量不需要显式定义.

自定义函数:
#+BEGIN_EXAMPLE
fn sqrt(x: f64) -> f64 {
  return x*x;
}
#+END_EXAMPLE
函数返回值以最后一个语句为准, 因此return可以略去(同时去掉最后的分号).

** TODO [2017-12-12 Tue] 使用rust实现之前写的files-coder
- [[https://github.com/hyperium/mime/][hyperium/mime: MIMEs in Rust]]

** [2017-12-10 Sun] 使用cargo来管理rust程序
: cargo new test1 --bin

: cargo run
快速语法检查:
: cargo check

* cargo
#+name: 7935cdce-84b1-4d22-a63d-7d0a8580a279
#+BEGIN_SRC conf :tangle Cargo.toml
  [package]
  name = "test1"
  version = "0.1.0"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [[bin]]
  name = "cmdline"
  path = "src/cmdline/main.rs"

  [dependencies]
  base64 = "*"
  clap = "*"
  zip = "*"
  nom = "*"

#+END_SRC

* tests [0/0]
** scratch
#+name: 26fc6fdf-a306-4357-aa27-ceeb00164a2d
#+begin_src shell :results output
  cargo run
#+end_src

** hamming distance
*** test
#+name: 18144448-0970-4f66-bbd3-f206635ba2cf
#+begin_src shell :results output
  cd exercism/rust/hamming
  cargo test -- --nocapture
#+end_src

#+RESULTS: 18144448-0970-4f66-bbd3-f206635ba2cf
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 7 tests
test test_first_string_is_longer ... ok
test test_complete_hamming_distance_in_small_strand ... ok
test test_larger_distance ... ok
test test_no_difference_between_empty_strands ... ok
test test_no_difference_between_identical_strands ... ok
test test_second_string_is_longer ... ok
test test_small_hamming_distance_in_the_middle_somewhere ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/hamming/src/lib.rs
:END:

#+name: 86e0273f-d292-4c9a-a644-a82b07625639
#+begin_src rust
  pub fn hamming_distance(s1: &str, s2: &str) -> Result <usize, String> {
      if s1.len() != s2.len() {
          return Err("err".to_string())
      } else {
          let l = get_hamming_distance(s1, s2);
          Ok(l)
      }
  }

  fn get_hamming_distance(s1: &str, s2: &str) -> usize {
      assert_eq!(s1.len(), s2.len());

      let mut sum = 0;
      for (c1, c2) in s1.chars().zip(s2.chars()) {
          if c1 != c2 {
              sum += 1;
          }
      }
      sum
  }
#+end_src

** reverse string
*** test
#+name: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_src shell :results output
  cd exercism/rust/reverse*
  cargo test
#+end_src

#+RESULTS: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 5 tests
test test_a_capitalized_word ... ignored
test test_a_palindrome ... ignored
test test_a_sentence_with_punctuation ... ignored
test test_a_word ... ignored
test test_empty_string ... ok

test result: ok. 1 passed; 0 failed; 4 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/reverse-string/src/lib.rs
:END:

#+name: 3d017385-a2ca-49af-8494-9b2dd4569f24
#+begin_src rust
  pub fn reverse(s: &str) -> String {
      s.chars().rev().collect::<String>()
  }
#+end_src

* reaction
** cargo
#+name: d5f68605-90cb-4b2b-b316-2025d935c17b
#+BEGIN_SRC conf :tangle reaction/Cargo.toml
  [package]
  name = "reac"
  version = "0.1.0"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  petgraph = "*"
#+END_SRC

** src
*** main
:PROPERTIES:
:header-args: :tangle reaction/src/main.rs
:END:
#+name: b8ea57f0-b549-4fa0-ac1a-abf83009009e
#+BEGIN_SRC rust
  extern crate petgraph;
  // use petgraph::prelude::*;
  use petgraph as pg;

  fn main() {
      println!("this is a hello {}", "world");
      let mut G = pg::Graph::new_undirected();
      let a = G.add_node(0);
      let b = G.add_node(1);
      G.add_edge(a, b, 2);
      let n = G.node_count();
      let nc = pg::algo::connected_components(&G);
      println!("{}  {}", n, nc);
  }
#+END_SRC

* src
** cmdline
:PROPERTIES:
:header-args: :tangle src/cmdline/main.rs
:END:

#+name: d0e077ec-1065-4135-a81d-db3d27ffd37e
#+begin_src rust
  extern crate clap;

  use std::env;
  use clap::{App, Arg};
  use std::io;
  use std::io::prelude::*;
  use std::fs::File;
  use std::io::BufReader;
  use std::cmp::Eq;


  #[derive (Default, Debug, PartialEq, PartialOrd, Clone)]
  /// Point3D, a point / position within 3D space
  pub struct Point3D {
      pub x: f64,
      pub y: f64,
      pub z: f64
  }

  impl Point3D {
      pub fn new(x: f64, y: f64, z: f64) -> Self {
          Point3D {x: x, y: y, z: z}
      }
  }

  impl Eq for Point3D {}

  #[test]
  fn point_3d_test() {
      let p = Point3D::new(0., 0., 0.);
      assert!(p.x == 0.);
      assert!(p.y == 0.);
      assert!(p.z == 0.);

      let p2 = Point3D::new(0., 0., 0.);
      assert!(p == p2);
  }


  fn readfile(filename: &str){
      let mut f = File::open(filename).expect("cannot open file");
      let reader = BufReader::new(f);
  }

  fn main() {
      // let args: Vec<String> = env::args().collect();
      // println!("{:?}", args);
      // println!("{:?}", args.len());
      let matches = App::new("MyApp")
          .version("0.1")
          .author("Wenping Guo <winpng@gmail.com>")
          .about("Does awesome things")
          .arg(
              Arg::with_name("debug")
                  .help("debug switch")
                  .long("debug")
                  .multiple(true)
                  .short("d")
          )
          .arg(
              Arg::with_name("input")
                  .help("set input file name")
                  .index(1)
          )
          .get_matches();

      match matches.occurrences_of("debug") {
          0 => println!("Debug mode is off"),
          1 => println!("Debug mode is kind of on"),
          2 => println!("Debug mode is on"),
          3 | _ => println!("Don't be crazy"),
      }

      if let Some(o) = matches.value_of("input") {
          println!("Value for input: {}", o);
          readfile(o);
      }
  }
#+end_src

** main
:PROPERTIES:
:header-args: :tangle src/main.rs
:END:

#+name: b08803c2-e9b1-4542-9574-b8c467d527b1
#+BEGIN_SRC rust
  // extern crate base64;
  #[macro_use]
  extern crate nom;

  fn sqrt(x: f64) -> f64 {
      let mut y:f64 = if x < 5. {5.} else {10.};
      loop {
          y += 1.;
          if y > 15. {
              break;
          }
      }
      y.sqrt()
  }

  fn test_tuple() -> (i32, i32){
      let t = (1, 2);
      let (a, b) = t;
      let i = 1;
      t
  }

  fn test_array() {
      let arr: [f64; 100] = [0.1; 100];
      println!("{:?}, {}", arr[10], arr.len());

      let mut arr = [1, 5, 3, 2];
      arr.sort();
      println!("{:?}", arr);
  }

  fn test_vector() {
      let mut v = vec![1, 2, 0, 5];
      v.insert(0, 13);
      assert_eq!(v, [13, 1, 2, 0, 5]);
      assert_eq!(v[0], 13);
      let v:Vec<i32> = (0..5).collect();
      println!("{:?}", v);
  }

  fn test_slice() -> i32 {
      let arr = [1, 2, 3, 4];
      let slice = &arr;
      let last = slice.get(3);
      println!("last = {}", last.unwrap());
      // println!("last = {}", arr[5]);
      ,*last.unwrap()
  }

  fn test_string () {
      // let mut s = "good to go to do".to_string();
      // s.push('好');
      // let x = s.pop();
      // println!("x={:?}, s={:?}", x.unwrap(), s);
      // println!("{}", "y̆".len());
      // println!("{:?}", "y̆".chars());
      let mut s = "good";
      println!("{:?}", s);
  }

  fn test_hashmap() {
      use std::collections::HashMap;
      let mut scores = HashMap::new();
      scores.insert("Blue", 10);
      // scores.insert("Blue", 20.); adding float will fail
      println!("{:?}", scores);
  }

  fn test_nom(){
      named!(get_greeting<&str,&str>,
             take_s!(2)
      );

      let res = get_greeting("hi there");
      println!("{:?}",res);
  }

  fn main() {
      // let bytes = base64::decode("aGVsbG8gd29ybGQ=").unwrap();
      // println!("{:?}", bytes);

      println!("this is a hello {}", "world");
      println!("{}", 12);

      let mut sum = 0.;
      for i in 0..5 {
          sum += i as f64;
          println!("loop: {}, sum = {}", i, sum);
      }

      let mut v = sqrt(sum);
      println!("{}", v);
      // test_hashmap();
      test_nom();
  }
#+END_SRC

* References
- [[https://rust-lang-nursery.github.io/rust-cookbook/basics.html][Rust Cookbook]]
- [[http://stevedonovan.github.io/rust-gentle-intro/readme.html][Introduction - A Gentle Introduction to Rust]]
- [[https://rustbyexample.com/][Introduction - Rust By Example]]
- [[https://learnxinyminutes.com/docs/rust/][Learn rust in Y Minutes]]

* Local variables
# Local Variables:
# mode: org
# end:

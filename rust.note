#+TITLE: Learn Rust: hack without fear!
#+SETUPFILE: ~/Notes/common.org
#+SETUPFILE: ~/Notes/latex.org
#+SETUPFILE: ~/Notes/coding.org

* Memo [2/23]
** TODO [2018-09-21 Fri] Rust 2018 edition变化很大 [[https://rust-lang-nursery.github.io/edition-guide/introduction.html][Introduction - The Edition Guide]]
** [2018-09-19 Wed] rust generator
- [[https://doc.rust-lang.org/unstable-book/language-features/generators.html][generators]]
- [[https://doc.rust-lang.org/std/ops/trait.Generator.html][std::ops::Generator - Rust]]
- [[https://github.com/Geal/generator_nom/blob/master/src/main.rs][generator_nom/main.rs at master · Geal/generator_nom]]

** [2018-08-24 Fri] 使用cross来静态编译 [[https://github.com/rust-embedded/cross][rust-embedded/cross: "Zero setup" cross compilation and "cross testing" of Rust crates]]
: cargo install cross
: cross build --target x86_64-pc-windows-gnu
: cross build --target x86_64-unknown-linux-musl

** [2018-08-09 Thu] 发现了一个新的解析库 [[https://github.com/Marwes/combine][Marwes/combine: A parser combinator library for Rust]]
** [2018-07-27 Fri] nalgebra使用笔记
matrix内部不管shape如何, 都是以linear的形式保存的.

比如Matrix3方阵:
: let a = Matrix3...
线性取值
: a[0], a[1], ..., a[8]

以行列号取值:
: a[(0, 0)], ..., a[(2, 2)]

** [2018-07-11 Wed] 代数运算 (GPU)新选择 [[https://github.com/arrayfire/arrayfire-rust][arrayfire/arrayfire-rust: Rust wrapper for ArrayFire]]
** [2018-06-25 Mon] string类函数参数泛化处理                       :Starred:
接受&str或String类型为String:
#+name: f99d74d4-39b9-42f6-a84a-c8ffb4811600
#+begin_src rust
  fn test<S: Into<String>(s: S) {
      //
  }
#+end_src

接受&str或String类型为&str:
#+name: 713d9c37-003c-4409-b700-d01b5ac5b1c7
#+begin_src rust
  fn test<S: AsRef<str>>(s: S) {
      //
  }
#+end_src

- https://doc.rust-lang.org/std/convert/trait.AsRef.html

** TODO [2018-06-24 Sun] rust 版本号管理规范 [[https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md][rfcs/1105-api-evolution.md at master · rust-lang/rfcs]]
** [2018-06-20 Wed] quicli中verbosity的问题
verbosity设置仅当为一个单独的binary crate时才有效, 如果是test或example模块无法使
用"-vv"命令选项设置log的level.

** TODO [2018-06-07 Thu] 帮宝儿一个mandelbrot set 游戏
- [[https://github.com/willi-kappler/mandel-rust][willi-kappler/mandel-rust: Mandelbrot set in rust, serial and parallel example]]
- [[https://github.com/pistondevelopers/image][PistonDevelopers/image: Encoding and decoding images in Rust]]

** TODO [2018-06-01 Fri] 并行计算库: [[https://github.com/actix/actix][actix/actix: Actor framework for Rust]]
** TODO [2018-05-31 Thu] 使用string来添加行
使用write宏
#+name: 51e9f2d6-180e-4fa7-86b1-68f2ae441a92
#+begin_src rust
  use std::fmt::Write;

  pub fn main() {
      let mut a = "hello ".to_string();
      write!(&mut a, "{}", 5).unwrap();

      println!("{}", a);
      assert_eq!("hello 5", a);
  }
#+end_src

使用string.push_str

** TODO [2018-05-20 Sun] 使用rsmpi来写mpi程序 [[https://github.com/bsteinb/rsmpi][MPI bindings for Rust]]
** TODO [2018-05-18 Fri] 可将python编译为python的项目 [[https://github.com/joncatanio/cannoli][joncatanio/cannoli: Cannoli Programming Language]]
** TODO [2018-05-11 Fri] 使用docker manylinux交叉编译环境
*** dockerfile
自制docker. 由于GFW, 变麻烦了很多. 需要下载rustup-init.she脚本, 修改其中的变量为
ustc.
#+name: ba3c4b7d-29aa-4849-9130-cd43db7d1806
#+BEGIN_SRC text :tangle ~/Incoming/docker/Dockerfile :comments no
  FROM quay.io/pypa/manylinux1_x86_64:latest
  MAINTAINER Wenping Guo <ybyygu@gmail.com>

  #VOLUME ${PWD}:/opt/volume

  COPY ./cargo-config /root/.cargo/config

  COPY ./rustup-init.sh /root/

  WORKDIR /root

  # install toolchain
  RUN env RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static \
      ./rustup-init.sh --default-toolchain nightly -y \

  ENV PATH=/root/.cargo/bin:$PATH
  ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib
#+END_SRC

参考:
- [[https://github.com/PyO3/setuptools-rust/blob/master/example/build-wheels.sh][setuptools-rust/build-wheels.sh at master · PyO3/setuptools-rust]]
- [[https://github.com/rust-lang/rust/blob/master/src/ci/docker/dist-x86_64-linux/Dockerfile][rust/Dockerfile at master · rust-lang/rust]]

*** enter
#+name: 4954e9ba-ee5f-40ef-9a44-9b2c330816e2
#+begin_src shell  :tangle ~/Incoming/docker/enter-manylinux.sh :shebang #!/usr/bin/env bash
  docker run \
         --rm \
         --interactive \
         --tty \
         --volume ${PWD}:/opt/volume \
         --workdir /opt/volume \
         quay.io/pypa/manylinux1_x86_64 \
         bash
#+end_src

*** compile wheel
#+name: 9682c20a-4e34-4105-9180-0a7c42b09ecf
#+BEGIN_SRC shell
  export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$HOME/rust/lib"
  export PYBIN=/opt/python/cp36-cp36m/bin
  export PATH=$PYBIN:$PATH
  export PYTHON_SYS_EXECUTABLE="$PYBIN/python"
  export PYTHON_LIB=$(${PYBIN}/python -c "import sysconfig; print(sysconfig.get_config_var('LIBDIR'))")
  export LIBRARY_PATH="$LIBRARY_PATH:$PYTHON_LIB"
  export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$PYTHON_LIB"
  "${PYBIN}/pip" install -U setuptools setuptools-rust wheel
  "${PYBIN}/pip" wheel ./ -w dist/
  auditwheel repair dist/*wheel -w dist/
#+END_SRC

试了pyo3的几个例子, 行不通. 暂时到此为止.

** [2018-05-10 Thu] HMM [[https://github.com/messense/jieba-rs/blob/master/src/hmm.rs][jieba-rs/hmm.rs at master · messense/jieba-rs]]
** [2018-05-10 Thu] 使用cargo版本变量, 太方便了.
: let version = env!("CARGO_PKG_VERSION");

** [2018-05-10 Thu] 可以用gtk-rs写一些GUI程序 [[https://gtk-rs.org/tuto/glade][Glade]]

** [2018-05-06 Sun] 施工中: unimplemented
可以用内置的宏:
: unimplemented!()
或者用error-chain中提供的宏:
: bail!("msg");

** [2018-05-06 Sun] trait object: 实现类似python中动态语言的特性
- [[https://doc.rust-lang.org/book/first-edition/trait-objects.html][Trait Objects - The Rust Programming Language]]
- [[https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html][Trait Objects for Using Values of Different Types - The Rust Programming Language]]
- [[https://brson.github.io/rust-anthology/1/all-about-trait-objects.html][All About Trait Objects]]

- trait是virtual的. trait object是指针化的trait, 可以实现一些需要运行时确定的动态特性.
- 不是所有的trait都可以转化为trait object, 需要满足object safe.
  - 如果我们不希望一个 trait 通过trait object的方式使用，可以为它加上Self: Sized约束。
  - 果我们想阻止一个函数在虚函数表中出现，可以专门为该函数加上Self: Sized约束

** [2018-04-30 Mon] 自定义公有macro
在mod文件头部:
: #![macro_use]
如果希望macro被外部crate使用, 需要:
: #[macro_export]

** [2018-04-26 Thu] fd: rust版find 还有一定的并行计算能力. 可以代替parallel
[[https://github.com/sharkdp/fd][sharkdp/fd: A simple, fast and user-friendly alternative to 'find']]

** TODO [2018-04-23 Mon] println输出格式
- [[https://doc.rust-lang.org/book/second-edition/ch05-02-example-structs.html][An Example Program Using Structs - The Rust Programming Language]]

When we have larger structs, it’s useful to have output that’s a bit easier to
read; in those cases, we can use {:#?} instead of {:?} in the println! string.
When we use the {:#?} style in the example, the output will look like this:

** TODO [2018-04-23 Mon] 可以从这里找rust库 libhunt [[https://rust.libhunt.com/][Awesome Rust]]
** TODO [2018-04-14 Sat] 也许可以用这个来调R中的包: [[https://github.com/rustr/rustr][rustr/rustr: Rust and R Integration]]
** [2018-04-10 Tue] 使用error-chain crate [[http://brson.github.io/2016/11/30/starting-with-error-chain][URL]]                      :Starred:
定义大致模板:
#+name: f6b7943a-e73f-4e73-b38d-2d433e999b78
#+begin_src rust
  // `error_chain!` can recurse deeply
  #![recursion_limit = "1024"]

  // Import the macro. Don't forget to add `error-chain` in your
  // `Cargo.toml`!
  #[macro_use]
  extern crate error_chain;

  // We'll put our errors in an `errors` module, and other modules in
  // this crate will `use errors::*;` to get access to everything
  // `error_chain!` creates.
  mod errors {
      // Create the Error, ErrorKind, ResultExt, and Result types
      error_chain!{}
  }

  // This only gives access within this module. Make this `pub use errors::*;`
  // instead if the types must be accessible from other modules (e.g., within
  // a `links` section).
  use errors::*;
#+end_src

使用chain_err来标记出错原因:
#+name: fce018e2-0071-4db6-9a0e-2dace68079c9
#+begin_src rust
  // Most functions will return the `Result` type, imported from the
  // `errors` module. It is a typedef of the standard `Result` type
  // for which the error type is always our own `Error`.
  fn run() -> Result<()> {
      use std::fs::File;

      // This operation will fail
      File::open("tretrete")
          .chain_err(|| "unable to open tretrete file")?;

      Ok(())
  }
#+end_src

使用bail!宏来自定义错误信息.
#+name: 513cd5fc-1b24-4ef4-a149-79e50eced9af
#+begin_src rust
  bail!("I don't like this: {}", nonsense);
#+end_src

可以用assure!宏来代替assert, 避免直接panic整个程序.
#+name: d7ee5c60-ba2a-4c48-8033-6175f1683967
#+begin_src rust
  ensure!(condition, "error code: {}", errcode);
#+end_src

** [2018-04-10 Tue] 禁用"unused code warnings"
: #![allow(dead_code)]
或者使用特殊变量名:
: let _unused_variable = 10;

** [2018-03-22 Thu] 使用just来做程序分布等后续工作 [[https://github.com/casey/just][casey/just]]
- 可以方便地静态编译,
- 添加各种编译优化选项
- 使用upx等减少程序体积.

** [2018-03-22 Thu] 防GFW [[https://lug.ustc.edu.cn/wiki/mirrors/help/rust-crates][Rust Crates 镜像使用帮助 {LUG@USTC}]]
#+name: fc33f678-42bd-4255-897e-278d935f737a
#+begin_src shell :tangle ~/Install/configs/rust/ustc.rc
  export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static
  export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup
#+end_src

** [2018-03-15 Thu] emacs中racer自动补全的问题
提示出错:
: No such directory: /home/ybyygu/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src.
: Please set ‘racer-rust-src-path’ or ‘RUST_SRC_PATH’)

解决方法:
: rustup component add rust-src

** TODO [2018-03-15 Thu] 使用[[https://github.com/TeXitoi/structopt][structopt]]+clap来写命令行程序
这里有些其它好东西: [[https://internals.rust-lang.org/t/announcing-the-cli-working-group/6872/16][Announcing the CLI Working Group - announcements - Rust Internals]]

- [[https://github.com/mitsuhiko/indicatif][mitsuhiko/indicatif: A command line progress reporting library for Rust]]

** [2018-03-14 Wed] rust写成的grep/ag工具, 更快 [[https://github.com/BurntSushi/ripgrep][BurntSushi/ripgrep: ripgrep recursively searches directories for a regex pattern]]

** [2018-03-14 Wed] rust写成的term, 特点是快 [[https://github.com/jwilm/alacritty][jwilm/alacritty: A cross-platform, GPU-accelerated terminal emulator]]

** [2018-03-13 Tue] clap的两个特别的宏, 可以使用crate中的版本信息  :Starred:
: crate_authors!()
: crate_version!()

** [2018-03-09 Fri] 如何组织代码: 这里解释的很清楚 [[https://learning-rust.github.io/docs/d1.code_organization.html][Modules | Learning Rust]]
- Functions
- Modules Can be mapped to a,
  - Inline module
  - File
  - Directory hierarchy

- Crates Can be mapped to a,
  - lib.rs file on the same executable crate
    - Dependency crate specified on Cargo.toml
      - Can be specified from,
        - path
        - git repository
        - crates.io

- Workspaces
  - Helps to manage multiple crates as a single project.

** [2018-03-09 Fri] 可以使用include_str和include_bytes宏来导入外部文件 :Starred:
- 从文件读入字串: [[https://doc.rust-lang.org/std/macro.include_str.html][std::include_str - Rust]]
- 从文件读入rust语句: [[https://doc.rust-lang.org/std/macro.include.html][std::include - Rust]]

导入的文件内容直接编译进入了binary.

** [2018-03-09 Fri] 使用cargo watch来自动化调试流程 [[https://github.com/passcod/cargo-watch][passcod/cargo-watch]] :Starred:
install
: cargo install cargo-watch
update
: cargo install --force cargo-watch

自动check && test
: cargo watch -x check -x test

这样org tangle代码后, 可以实时看到代码结果输出. 比ipython里的module reload还强.

** [2018-03-09 Fri] 查看rust离线文档                               :Starred:
standard library API
#+name: 24b9ac82-3bf2-41fc-bf94-b98acc5c3d78
#+begin_src shell  :results silent
  rustup doc --std
#+end_src

TRPL book:
#+name: d90e46ed-4933-4c8b-b9cb-af024904d6df
#+begin_src shell :results silent
  rustup doc --book
#+end_src

** TODO [2018-03-08 Thu] rust notes
I would tell someone: don't expect to learn it fast. I've heard it said that you
can learn Go in a week. You can't learn Rust in a week, not in depth anyway. And
learning it requires grit, especially in the beginning. Also: its super helpful
to actually read rust code, not just struggle to write it. rustbyexample.com is
good, but its really useful to just read code that is written by the Rust
Masters: https://github.com/rust-lang-nursery/futures-rs is a good example.

** [2018-03-08 Thu] 使用examples [[http://xion.io/post/code/rust-examples.html][Karol Kuczmarski's Blog – Add examples to your Rust libraries]]
太有用了.

** [2018-03-08 Thu] 这个也不错 [[https://github.com/carols10cents/rustlings][carols10cents/rustlings: Small exercises to get you used to reading and writing Rust code]]
** [2018-03-07 Wed] 修改cargo编译目录
将其放到~/.cache目录下. 以减轻外围同步脚本的负担.

#+name: cb0473ce-cfbe-4e19-b3e8-5d4622533a6e
#+begin_src shell
  _cargo()
  {
      if [ -f ./Cargo.toml ]; then
          rootdir=$(basename $(pwd))
          CARGO_TARGET_DIR=~/.cache/cargo/$rootdir cargo "$@"
      else
          cargo "$@"
      fi
  }
  alias cargo=_cargo
#+end_src
以上脚本放在~/.zsh_alias中.

** [2018-03-02 Fri] 使用musl库, 实现纯静态编译
- 使用rustup安装nightly版本
- rustup set target
  : rustup install nightly
  : rustup default nightly
  : rustup target add x86_64-unknown-linux-musl
  # rustup set default-host x86_64-unknown-linux-musl
- 使用rustup自带cargo编译
  : cargo build --release --target x86_64-unknown-linux-musl

编译后比普通版大两倍(1.5 vs 5.4). 不过可以接受.

References
- [[https://blog.rust-lang.org/2016/05/13/rustup.html][Taking Rust everywhere with rustup - The Rust Programming Language Blog]]

** [2018-02-19 Mon] rust升级至1.24, 新功能: 增量编译. 调代码效率可以高一些了.
** [2018-02-19 Mon] cgmath基本用法
: np.linalg.norm => vector.magnitude()
: mat.T => mat.transpose()
: np.linalg.inv(mat) => mat.invert()

array to Point3
: Point3::from([0.0; 3]);

** [2018-02-18 Sun] 使approx crate来测试浮点数值的匹配性
#+name: c388cfa1-83ec-4833-af78-b3a6698def26
#+begin_src rust
  #[macro_use]
  extern crate approx;

  assert_relative_eq!(expected, actual, epsilon=1e-4);
#+end_src

** [2018-02-18 Sun] Rust中的浮点数没有实现全序, 不能使用max, min函数
: [0.0, xy, xz, xy+xz].iter().fold(f64::MIN, |a, &b| a.max(b));

** DONE [2018-02-17 Sat] ovito输出至POSCAR后 原子次序会重排. 需要结构提取功能.
CLOSED: [2018-02-20 Tue 20:09]
- State "DONE"       from "TODO"       [2018-02-20 Tue 20:09]
需要写一个能输出CIF文件的程序. 保留原子次序和键连关系.

- [X] 周期性镜像原子间的成键问题.

** [2018-02-16 Fri] iterator.peek的用法
很容易报错:
: cannot move out of borrowed content

正确的写法:
#+name: 3be15f32-d8d6-4da9-be88-d0076cf849cb
#+begin_src rust
  lines_iter = fp.lines().peekable();
  if let Some(&Ok(ref firstline)) = lines_iter.peek() {
      if ! firstline.starts_with("LAMMPS data file") {
      }
      ...
  }
#+end_src

** TODO [2018-02-13 Tue] rust测试工具
测试分为集成测试和单元测试. 单元测试是开发者站在内部的角度来写, 测试代码和功能代
码放在一起, 可以自由访问任意变量和函数. 集成测试是站在外部使用者的角度来写的, 测
试代码放在和src目录同级的tests目录下, 目的是测试整个程序的集成效果.

代码标注:
: #[test]
或
: #[test]
: #[ignore]
这样测试里会忽略.

测试:
: cargo test

可以将test代码放到mod里, 以#[cfg(test)]标注, 这样可以减少最终执行文件的大小.

集成测试中的代码适合放练手代码, 不需要写主程序, 不会被编入其它主程序中. 用cargo
很容易调用:
: cargo test -- --nocapture

** TODO [2018-02-04 Sun] 快被String, str, &str, "str"之间的区别搞死了
- literal string是静态分配的常量, 和整型, 浮点数一样的语义.
- String是动态分配的, 可变的字符串. self-owned. 函数定义时, 优先用这个, 省掉不少
  麻烦.
- &String是对String的只读引用.
- &str是string slice.

** [2018-02-04 Sun] rust现在还不支持函数中使用默认参数 [[https://users.rust-lang.org/t/default-values-for-function-parameters/12483/3][URL]]
** DONE [2018-02-03 Sat] 如何写一个能接受Iterator类型的函数
CLOSED: [2018-02-13 Tue 12:34]
- State "DONE"       from "TODO"       [2018-02-13 Tue 12:34]
- [[https://stackoverflow.com/questions/43057946/how-do-i-write-a-function-in-rust-that-accepts-any-iterator-whose-item-fulfills][How do I write a function in Rust that accepts any iterator whose Item fulfills a trait?]]

#+name: 05a53a8c-ff59-4a92-8181-e97a028f9545
#+begin_src rust
  fn parse_lammps_bonds_single_snapshot<I>(lines_iter: &mut I) -> Result<String, String>
      where I: Iterator<Item=io::Result<String>>
  {
      ;
  }
#+end_src

** TODO [2018-02-02 Fri] 错误处理
- [[https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-][A Shortcut for Propagating Errors: ?]]

函数返回类型:
: -> Result<(), Box(Error)>

** [2018-02-01 Thu] Eq与PartialEq
- [[https://doc.rust-lang.org/std/cmp/trait.PartialEq.html][std::cmp::PartialEq - Rust]]
- [[https://doc.rust-lang.org/std/cmp/trait.Eq.html][std::cmp::Eq - Rust]]
- [[https://doc.servo.org/core/cmp/trait.Ord.html][core::cmp::Ord - Rust]]

Eq是PartialEq的加强版.

PartialEq不要求自相等. 比如: a可以不等a(以浮点数为例).

** [2018-01-31 Wed] 使用petgraph来操作图论结构 [[https://github.com/bluss/petgraph][petgraph]]
第一印象: 没有networkx的api那么方便.

求connected_components用petgraph::algo::kosaraju_scc即可.

有三种graph类型.

*** Graph
: let node_index = G.add_node(weight);
这和networkx的语法不同, add_node的参数是weight, 不是node数据. 返回值为node_index.

: let edge_index = G.add_edge(n1, n2, edage_data);
n1, n2为node_indices, edage_data可为任意数据类型. 返回值为edge_index

: let node_weight = &G[node_index];
: let edge_weight = &G[edge_index];
有了indices, 可以方便地访问graph节点和边关联的数据.

add_edge时需注意:默认petgraph充许parallel edges, 因此多次添加edge时, 会生成两个
节点间的多个边. 使用update_edge函数可避免这个问题.
*** GraphMap
这个更接近于networkx中的Graph对象的实现方式. 基于petgraph作者写的[[https://github.com/bluss/ordermap][ordermap]] (后续
可能会换名字: IndexMap).

不充许parallel-edge(两个不同节点间有多条边), 但充许有self-loop(同一节点间形成的
边).

: G.add_node(n);
其kosaraju_scc中n用来指示不同的node. 不能设定node data, 或者说n本身就是data(结构体).

: G.add_edge(n1, n2, edge_data);
添加节点n1和n2之间的边.

*** StableGraph

** TODO [2018-01-28 Sun] 使用nom解析格式化文件
- [[https://stevedonovan.github.io/rust-gentle-intro/nom-intro.html#parsing-text-with-nom][Parsing with Nom - A Gentle Introduction to Rust]]
- [[http://rust.unhandledexpression.com/nom/][nom - Rust]]

注意tag_s等宏被弃用, 可以直接用tag等代替.

nom的优点:
- 解析单元可自由组合 (parser combinator library)
- 容易调试, 容易集成. 方便实现更复杂的解析逻辑
- 比regex更快.

ws! 吃掉空格字符, 包括换行符.

解析函数:
: let x = float_s("1.423E-3");

对于简单的xyz list字串, debug build下总体上比常规手写要慢约4倍, 但release优化后,
性能甚至超过常规. 挺堪一用的.

使用split_whitespace和parse函数:
: line.split_whitespace().map(|x| x.parse().unwrap()).collect()
// debug 5.9 µs, release: 569.3 ns

使用nom double_s
: many_m_n!(3, 3, ws!(double_s))
// debug: 32.1 µs, release: 630.4 ns

不对double字符检测, 直接parse_to
: flat_map!(recognize!(is_not_s!(" \t")), parse_to!(f64))
: ...
// debug: 22.3 µs, release: 462.6 ns

不对double字符检测, 直接map_res, parse
: map_res!(is_not_s!(" \t"), str::parse)
: ...
// debug: 21.1 µs, release: 457.2 ns

如果使用tuple!宏来替换many_m_n!可以进一步提升性能(457 --> 384).

** [2018-01-19 Fri] 文件读写
- [[https://doc.rust-lang.org/std/fs/struct.File.html][std::fs::File - Rust]]
- [[https://doc.rust-lang.org/std/io/index.html][std::io - Rust]]
- [[https://doc.rust-lang.org/std/io/struct.BufReader.html][std::io::BufReader - Rust]]

*** reader.read_line
需要string参数. 将新读入的一行数据附加到buf中. 返回读入的字节数.

** [2018-01-18 Thu] Result和Option类型
Result枚举类型是对所有返回值的完全分类：正常（Ok）或出错（Err）。Option枚举类型
是对所有可选项的完全分类，有值（Some）或无值（None）。

Result和Option经常用于匹配参数返回不同数据上（match）。

Reference
- [[https://doc.rust-lang.org/std/result/][std::result - Rust]]
- [[https://doc.rust-lang.org/std/option/][std::option - Rust]]

** [2018-01-18 Thu] [[https://blog.rust-lang.org/2017/12/21/rust-in-2017.html][Rust in 2017: what we achieved]]
感觉上是python和C的完美结合.

- [[https://github.com/rust-lang-nursery/tempdir][rust-lang-nursery/tempdir: Temporary directory management for Rust]]
- [[https://github.com/rayon-rs/rayon][rayon-rs/rayon: Rayon: A data parallelism library for Rust]]

** TODO [2018-01-17 Wed] 使用log工具
- [[https://github.com/rust-lang-nursery/log][rust-lang-nursery/log: Logging implementation for Rust]]

log将和slog合并: [[https://github.com/rust-lang-nursery/log/issues/149][Structured Logging · Issue #149 · rust-lang-nursery/log]]

** [2018-01-17 Wed] rust基础练习4: 简单命令行界面
可以使用std::env来提取. env::args返回的是Iterator, 其中每个参数都为string类型.

复杂点的可以用[[https://github.com/kbknapp/clap-rs][clap]].

** [2018-01-01 Mon] rust ownership :ATTACH:
:PROPERTIES:
:ID:       dfcf2ff4-7214-483f-8b66-bf76a0372e8a
:Attachments: rust-intro-2018-01-01142409_2018-01-01_14-26-11.png
:END:

#+DOWNLOADED: @ 2018-01-01 14:26:11
#+attr_org: :width 600
#+attr_odt: :width 8
[[file:data/df/cf2ff4-7214-483f-8b66-bf76a0372e8a/rust-intro-2018-01-01142409_2018-01-01_14-26-11.png]]

** TODO [2017-12-30 Sat] 完成[[http://exercism.io/languages/rust/exercises][exercism.io]]上的练习
** TODO [2017-12-30 Sat] 使用rust来完成之前写的lindermann指数计算程序
** [2017-12-26 Tue] rust基础练习3 基本数据结构
*** tuple
: tuples like (1, true)
- tuple中的数据通常是不同类型的.
- 通过tuple, 函数可以返回多个数值.

tuple输出时:
: println("{:?}", (1, 2));

tuple可以通过位置来指认:
#+name: 7db31524-8474-431d-8e3c-279dd552c4e3
#+begin_src rust
  let t = (1, 2);

  print!("{}, {}", t.0, t.1);
#+end_src

可以像python一样, 可以把tuple展开给多个变量:
#+name: efd8cd2d-26a7-47da-a4ab-841a2f6a1396
#+begin_src rust
  let t = (1, 2, 3);
  let (a, b, c) = t;
#+end_src
注意左侧的变量要用tuple的形式括起来, 否则会报错. 这也python不同.

注意tuple引用内部成员时不能使用变量, 也不能像python的那样来取值. 下面的语句是错的:
: let t = (12, 2, 'a');
: let i = 1;
: println! ("{}", t.i);  // 错误
: println! ("{}", t[0]); // 错误

只有一个成员的tuple, 后面的逗号不能省略:
: let t = (12,);

无成员类型:
: let t = ();

函数无返回值时, 默认返回(), 相当于python中的None?

还有一点与python不同. 因为tuple中成员类型不同, 用于loop时没意义. 可以换array来更
好的实现相应的功能.

*** arrays, slices
: arrays like [1, 2, 3]
rust中的array和C里的静态数组类似, 成员类型要一致, 运行时不可增删.
#+name: 263760d4-6182-4794-8e27-704b2aa61a31
#+begin_src rust
  let arr = [1, 2, 5, 9, 10];
  println!("{}", arr[0], array[2]);
#+end_src
如何访问数组成员越界, rust在编译时就会报错.

成员函数:
: arr.len();
: arr.sort();

数组声明时, 要指明成员数值类型及成员数:
: let arr: [i32; 5] = [1, 2, 3, 4, 6];
注意中间用的是分号.
: let arr: [i32; 500] = [12; 500];
注意右侧的值为500个12.

如果要使用range来提取多个数值, 需要取址, 用slice:
: &arr[1..5]

二维数组:
#+name: ec1673bf-357a-475c-bb95-ff63fe463bc2
#+begin_src rust
  let arr = [[1, 5], [2, 4]];
  println!("{:?}", arr[0][1]);
#+end_src

slice在运行期才能知道数组的大小, 为了避免panic, 可以用slice.get方法
#+name: f9bd3ee7-0cce-4adc-a0da-cf3a440101b4
#+begin_src rust
  let arr = [1, 2, 3, 4];
  let slice = &arr;
  let last = slice.get(5);
#+end_src
这与python中的dict.get类似. slice访问如果越界, 会返回一个特殊的数据结构Option,
值为None.

Option对象可用函数:
: last.is_some();
: last.is_none();
如果opt有值, 可以提出来:
: last.unwrap();
如果opt是None, unwrap的话运行时会panic.

更便捷的方式是使用unwrap_or
: last.unwrap_or(&-1)
注意参数用&取址.

注意last.unwrap()取出的数据为reference, 不是实在的数据. 记得根据需求解引:
: *last.unwrap()
*** vector
vector是动态数组, 同array一样, 成员类型要一致.

声明变量:
: let v = vec![2, 3, 1, 5];
或者:
: let v = Vec::new();
: v.push(2);
: ...

可以从iterator初始化:
: let v:Vec<i32> = (0..5).collect();
注意v要指明类型.

添加元素:
: v.push(1);

插入元素:
: v.insert(1, 'a');

删除元素:
: v.remove(1);

*** string
**** char
单引号: char
双引号: literal string

**** str, string literal
双引号中的为literal string (&'static str). literal string为静态数据类型, 就像是
整型, 浮点型.

中间可以包括硬回车或转义字符.
#+name: c0f6ce7f-deac-4321-9c14-4312a9518957
#+begin_src rust
  let s = "good to go\n";

  let s = "good
  to go";

  // s = good togo
  let s = "good to\
           go";
#+end_src
字串中可以使用~\~来续行.

raw string:
#+name: 3de9f418-5b32-42b6-bf5c-6285b458ad7c
#+begin_src rust
  // s = "\n\n"
  let s = r"\n\n";
#+end_src

lieral string可用的函数:
: s.len();
与python不同, rust中的string不能index, 比如s[0], 但可以slice:
#+name: 7a55e292-1387-4cdc-8f05-14e9ed00c888
#+begin_src rust
  let s = "abcdef";
  let subs = &s[1..2]
#+end_src

对于多行文本, 可以直接使用lines函数来对行进行枚举操作.
: txt.lines()

**** String
内存动态分配的string.

[[https://doc.rust-lang.org/std/string/struct.String.html][std::string::String - Rust]]

A UTF-8 encoded, growable string

初始化:
: let s = String::new();
: let s = String::from("world");
: let s = "Hello".to_string();

修改字串:
string.push, string.push_str, string.pop, string.remove, string.insert, string.insert_str, string.truncate, string.clear
: s.push('1');
: s.push('好');
: s.push_str("bar");

可以像python一样, 使用"+"来合并字串:
#+name: 9e15f850-01c6-4368-b21e-fe560b347feb
#+begin_src rust
  let mut s = "good to go to do".to_string();
  s.push('d');
  println!("{}", s + "good");
#+end_src

使用format! macro来生成格式化字符串.
#+name: 21f9c2a1-d351-468e-a414-c37f018903df
#+begin_src rust
  let s = format!("{}", 2.2);
#+end_src

合并字串
#+name: 425fe069-3e10-417a-8929-2551b7417db2
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.concat();
#+end_src

像python中的str.join
#+name: f91f9154-1da8-4788-a969-dc72a2e281c1
#+begin_src rust
  let bits = vec!["a", "b", "c"];
  let s = bits.join("\n");
#+end_src

取子串:
: s.chars()

其它:
contains, replace, trim, split

测试:
string.contains, string.starts_with, string.ends_with, string.find

其它:
string.split, string.trim, string.repeat
: assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));

iteration
string.chars

&string: shared reference to string
&str: string slice
*** TODO hash maps
- [[https://doc.rust-lang.org/book/second-edition/ch08-03-hash-maps.html][Hash Maps - Hash Maps - The Rust Programming Language]]

*** TODO structs
这个像namedtuple, C里的结构体. 通名称来指认内部成员更方便些.

** [2017-12-21 Thu] rust基础练习2 control flow
#+name: 5fde93b8-94a6-4341-9db8-f3625238dfc5
#+BEGIN_SRC rust
  if (a < b) {
      println!("{}", 1);
  } else {
      println!("{}", 2);
  }
#+END_SRC

如果是多个条件:
: else if

注意if等判断语句后跟bool类型. rust不会像python做隐式类型转换. 比如下面的语句会报错:
#+name: be800e54-711b-4393-aefb-811c41ba2b7a
#+begin_src rust
  let r = 1;
  if r {...};
#+end_src

也可以像python写成单行表达式
#+name: 632a594b-c4a8-48db-ab4d-f176d44954b2
#+BEGIN_SRC rust
  let y:f64 = if a < 4. {1.} else {2.}
#+END_SRC
此时要注意, else前后的返回值类型要一致, 否则会报错.

循环结构可以用loop, while, for. break/continue同样可用.

对于多层循环, rust中可以使用标签, 然后break到指定位置. 见[[https://rustbyexample.com/flow_control/loop/nested.html][doc]].

rust使用match来实现像C里的switch语句类似的功能.

** [2017-12-20 Wed] rust基础练习1 变量常量类型
常量定义:
: let sum = 0;

变量定义:
: let mut sum = 0;

上面的sum变量被定义为整型, 可以加和整型数据.

如果sum定义为浮点数:
: let mut sum = 0.;
: sum += 1;
自加和整型数1会报错. 需要对1进行显式的类型转换:
: sum += 1 as f64;
或者:
: sum += 1_f64;

如果是变量必须用"as f64"
: sum += i as f64;

rust对数值类型要求很严, 整数除以浮点数会报错
: 12/2.

整数除以整数会得到一个整数:
: 13/6
上面的值为2

常见的数值类型: i32, i64, u32, u64, f32, f64

rust避免做任何假设, 这倒是免掉了C里面的不少坑.


常见数值运算: [[https://doc.rust-lang.org/std/primitive.f64.html][docs]]
: x.abs()
: x.powf(2.)
: x.sqrt()

#+name: dac3cc9f-d575-49e3-a759-49a1f88224e8
#+BEGIN_SRC rust
  for i in 0..5 {
      println!("loop {}", i);
  }
#+END_SRC

loop变量不需要显式定义.

自定义函数:
#+BEGIN_EXAMPLE
fn sqrt(x: f64) -> f64 {
  return x*x;
}
#+END_EXAMPLE
函数返回值以最后一个语句为准, 因此return可以略去(同时去掉最后的分号).

** TODO [2017-12-12 Tue] 使用rust实现之前写的files-coder
- [[https://github.com/hyperium/mime/][hyperium/mime: MIMEs in Rust]]

** [2017-12-10 Sun] 使用cargo来管理rust程序
: cargo new test1 --bin

: cargo run
快速语法检查:
: cargo check

测试:
: cargo test
测试时允许print语句输出:
: cargo test -- --nocapture

* Libraries
各种细分领域crates总结:
- [[http://arewegameyet.com/][Are we game yet? - Rust]]
- [[http://www.arewelearningyet.com/][Are we learning yet?]]
- [[http://www.arewewebyet.org/][Are we web yet? » AWWY?]]
- [[https://areweideyet.com/][Are we (I)DE yet?]]

常用库:
- [[https://github.com/hniksic/rust-subprocess][hniksic/rust-subprocess: Execution of and interaction with external processes and pipelines]]
- [[https://github.com/philippkeller/rexpect][philippkeller/rexpect: Rust port of pexpect]]
- [[https://github.com/FGRibreau/spinners][FGRibreau/spinners: 60+ Elegant terminal spinners for Rust]]
- [[https://github.com/noshu/lbfgsb-sys][noshu/lbfgsb-sys: Rust binding of fortran Limited memory LBFGS subroutine]]

* TODO FFI
- [[https://github.com/alexcrichton/rust-ffi-examples][alexcrichton/rust-ffi-examples: FFI examples written in Rust]]

* cargo
#+BEGIN_SRC conf :tangle Cargo.toml
  [package]
  name = "test1"
  version = "0.1.0"
  edition = "2018"
  authors = ["Wenping Guo <ybyygu@gmail.com>"]

  [dependencies]
  base64 = "*"
  clap = "*"
  pyo3 = ">=0.4"
  zip = "*"
  nom = "*"
  timeit = "*"
  petgraph = ">=0.4.13"
  approx = "*"
  nalgebra = "*"
#+END_SRC

* src
** cmdline
:PROPERTIES:
:header-args: :tangle src/cmdline/main.rs
:END:

#+name: d0e077ec-1065-4135-a81d-db3d27ffd37e
#+begin_src rust
  extern crate clap;

  use std::env;
  use clap::{App, Arg};
  use std::io;
  use std::io::prelude::*;
  use std::fs::File;
  use std::io::BufReader;
  use std::cmp::Eq;


  #[derive (Default, Debug, PartialEq, PartialOrd, Clone)]
  /// Point3D, a point / position within 3D space
  pub struct Point3D {
      pub x: f64,
      pub y: f64,
      pub z: f64
  }

  impl Point3D {
      pub fn new(x: f64, y: f64, z: f64) -> Self {
          Point3D {x: x, y: y, z: z}
      }
  }

  impl Eq for Point3D {}

  #[test]
  fn point_3d_test() {
      let p = Point3D::new(0., 0., 0.);
      assert!(p.x == 0.);
      assert!(p.y == 0.);
      assert!(p.z == 0.);

      let p2 = Point3D::new(0., 0., 0.);
      assert!(p == p2);
  }


  fn readfile(filename: &str){
      let mut f = File::open(filename).expect("cannot open file");
      let reader = BufReader::new(f);
  }

  fn main() {
      // let args: Vec<String> = env::args().collect();
      // println!("{:?}", args);
      // println!("{:?}", args.len());
      let matches = App::new("MyApp")
          .version("0.1")
          .author("Wenping Guo <winpng@gmail.com>")
          .about("Does awesome things")
          .arg(
              Arg::with_name("debug")
                  .help("debug switch")
                  .long("debug")
                  .multiple(true)
                  .short("d")
          )
          .arg(
              Arg::with_name("input")
                  .help("set input file name")
                  .index(1)
          )
          .get_matches();

      match matches.occurrences_of("debug") {
          0 => println!("Debug mode is off"),
          1 => println!("Debug mode is kind of on"),
          2 => println!("Debug mode is on"),
          3 | _ => println!("Don't be crazy"),
      }

      if let Some(o) = matches.value_of("input") {
          println!("Value for input: {}", o);
          readfile(o);
      }
  }
#+end_src

** main
:PROPERTIES:
:header-args: :tangle src/main.rs
:END:
*** globals
#+name: f8c09544-ff6f-4589-9c06-d83d9b36e3ab
#+begin_src rust
  // extern crate base64;
  #[macro_use]
  extern crate nom;
  extern crate petgraph;
#+end_src

*** basis
#+name: b08803c2-e9b1-4542-9574-b8c467d527b1
#+BEGIN_SRC rust
  fn sqrt(x: f64) -> f64 {
      let mut y:f64 = if x < 5. {5.} else {10.};
      loop {
          y += 1.;
          if y > 15. {
              break;
          }
      }
      y.sqrt()
  }

  fn test_tuple() -> (i32, i32){
      let t = (1, 2);
      let (a, b) = t;
      let i = 1;
      t
  }

  fn test_array() {
      let arr: [f64; 100] = [0.1; 100];
      println!("{:?}, {}", arr[10], arr.len());

      let mut arr = [1, 5, 3, 2];
      arr.sort();
      println!("{:?}", arr);
  }

  fn test_vector() {
      let mut v = vec![1, 2, 0, 5];
      v.insert(0, 13);
      assert_eq!(v, [13, 1, 2, 0, 5]);
      assert_eq!(v[0], 13);
      let v:Vec<i32> = (0..5).collect();
      println!("{:?}", v);
  }

  fn test_slice() -> i32 {
      let arr = [1, 2, 3, 4];
      let slice = &arr;
      let last = slice.get(3);
      println!("last = {}", last.unwrap());
      // println!("last = {}", arr[5]);
      ,*last.unwrap()
  }

  fn test_string () {
      // let mut s = "good to go to do".to_string();
      // s.push('好');
      // let x = s.pop();
      // println!("x={:?}, s={:?}", x.unwrap(), s);
      // println!("{}", "y̆".len());
      // println!("{:?}", "y̆".chars());
      let mut s = "good";
      println!("{:?}", s);
  }

  fn test_hashmap() {
      use std::collections::HashMap;
      let mut scores = HashMap::new();
      scores.insert("Blue", 10);
      // scores.insert("Blue", 20.); adding float will fail
      println!("{:?}", scores);
  }

#+END_SRC

*** nom
#+name: 76f3c475-acd4-492d-b4fc-50da7265bfd9
#+begin_src rust
  fn test_nom(){
      named!(get_greeting<&str,&str>,
             take_s!(2)
      );

      let res = get_greeting("hi there");
      println!("{:?}",res);
  }
#+end_src

*** atoms
定义最简单的原子结构信息.
#+name: 1f84ef01-7ddb-4295-8521-c29ad7d7e059
#+begin_src rust
  use std::hash::{Hash, Hasher};
  use std::cmp::Ordering;

  #[derive (Default, Debug, Clone, Copy)]
  /// simple atom data structure
  pub struct Atom {
      pub index: u64,
      pub symbol: &'static str,
  }

  impl PartialEq for Atom {
      fn eq(&self, other: &Atom) -> bool {
          self.index == other.index
      }
  }

  impl Eq for Atom {}

  impl Hash for Atom {
      fn hash<H: Hasher>(&self, state: &mut H) {
          self.index.hash(state);
      }
  }

  impl Ord for Atom {
      fn cmp(&self, other: &Atom) -> Ordering {
          self.index.cmp(&other.index)
      }
  }

  impl PartialOrd for Atom {
      fn partial_cmp(&self, other: &Atom) -> Option<Ordering> {
          Some(self.cmp(other))
      }
  }

  #[test]
  fn test_atom() {
      let a = Atom{
          index: 1,
          symbol: "H",
      };

      let b = Atom {
          index: 2,
          symbol: "H",

      };
      let mut c = Atom {
          index: 1,
          symbol: "H",
      };

      assert!(a != b);
      assert!(a == c);

      assert!(a.index == 1);
      assert!(a.symbol == "H");

      c.symbol = "C";
      assert!(c.symbol == "C");
  }
#+end_src

实现从元素符号列表到分子式.
#+name: 27fa4abe-d98c-4dd4-8695-e4b4f807cabc
#+begin_src rust
  use std::collections::HashMap;

  // fn get_reduced_formula<'a, I>(symbols: I) -> Option<&'static str>
  //     where I: Iterator<Item=&'static str>,
  // {
  //     for x in symbols {
  //         println!("{:?}", x);
  //     }

  //     Some("C2H4")
  // }

  fn get_reduced_formula(symbols: &[&str]) -> String {
      let mut counts = HashMap::new();
      for x in symbols {
          let c = counts.entry(x).or_insert(0);
          ,*c += 1;
      }

      let mut syms: Vec<String> = Vec::new();
      let mut to_append = String::new();

      for (k, v) in counts {
          let reduced = format!("{}{}", k, v);
          if *k == "C" {
              syms.insert(0, reduced);
          } else if *k == "H" {
              to_append = reduced;
          } else {
              syms.push(reduced);
          }
      }
      syms.push(to_append);
      let formula = syms.join("");
      formula
  }

  #[test]
  fn test_formula() {
      let symbols   = vec!["C", "H", "C", "H", "H", "H"];
      let formula = get_reduced_formula(&symbols);
      assert!(formula == "C2H4".to_string());
      let symbols   = vec!["C", "H", "C", "H", "H", "O", "H", "O"];
      let formula = get_reduced_formula(&symbols);
      println!("{:?}", formula);
      assert!(formula == "C2O2H4".to_string());
  }
#+end_src

*** petgraph
#+name: deb8ea39-2a90-4db1-987b-121d98047d53
#+begin_src rust
  fn test_petgraph() {
      use petgraph as pg;
      use std::collections::HashMap;

      let mut G = pg::Graph::new_undirected();
      let aa = [0; 4];
      let bb = [1; 4];
      let x = G.add_node(aa);
      let y = G.add_node(bb);
      let e = G.add_edge(x, y, (1, 1));
      let f = G.add_edge(x, y, (2, 2));
      println!("{:?}", &G[x]);
      println!("{:?}", &G[y]);
      println!("{:?}", e);
      println!("{:?}", &G[e]);
      println!("{:?}", f);
      println!("{:?}", &G[f]);
  }

  fn test_petgraph_graphmap() {
      use petgraph as pg;
      use petgraph::prelude::*;
      let mut G = UnGraphMap::new();

      let a = Atom{
          index: 1,
          symbol: "H",
      };

      let b = Atom{
          index:2,
          symbol:"H",
      };

      println!("{:?}, {:?}", a, b);
      G.add_node(a);
      G.add_node(b);
      G.add_edge(a, b, 1);
      println!("{:?}", &G);
      println!("{:?}", &G[(a, b)]);
  }
#+end_src

*** cmdline
#+name: 82c97bbd-b1b7-492e-8aa2-31271b45b049
#+begin_src rust
  fn main() {
      // let bytes = base64::decode("aGVsbG8gd29ybGQ=").unwrap();
      // println!("{:?}", bytes);

      // println!("this is a hello {}", "world");
      // println!("{}", 12);

      // let mut sum = 0.;
      // for i in 0..5 {
      //     sum += i as f64;
      //     println!("loop: {}, sum = {}", i, sum);
      // }

      // let mut v = sqrt(sum);
      // println!("{}", v);

      test_petgraph_graphmap();
  }
#+end_src

* tests
** pyo3
:PROPERTIES:
:header-args: :tangle tests/test_pyo3.rs
:END:
#+begin_src rust
  #![feature(specialization)]
  use pyo3::prelude::*;

  #[test]
  fn test_pyo3() -> PyResult<()>{
      let gil = Python::acquire_gil();
      let py = gil.python();
      let sys = py.import("sys")?;
      // let version: String = sys.get("version")?.extract()?;
      let version = sys.get("version")?;
      println!("{:#?}", version);

      // how to call python function?
      // aseio: PyMoudle
      let aseio = py.import("ase.io")?;
      // atoms: PyObjectRef
      let atoms = aseio.call1("read", "/tmp/a.xyz")?;
      // positions: PyObjectRef
      let positions = atoms.getattr("positions")?;
      let positions = positions.call_method0("tolist")?;
      let x: Vec<Vec<f64>> = positions.extract()?;
      println!("{:?}", x);

      Ok(())
  }
#+end_src

** nalgebra
:PROPERTIES:
:header-args: :tangle tests/test_nalgebra.rs
:END:
#+name: 78136a22-35fb-48a1-9e90-f22453748f0f
#+begin_src rust
  #[macro_use] extern crate approx;

  extern crate nalgebra;
  use nalgebra as na;

  /// Vector in 3D space
  pub type Vector3f = na::Vector3<f64>;

  /// 3xN matrix storing a list of 3D vectors
  pub type Vector3fVec = na::Matrix<f64, na::U3, na::Dynamic, na::MatrixVec<f64, na::U3, na::Dynamic>>;

  /// Cartesian 3D coordinates
  pub type Position = Vector3f;
  /// A list of 3D position vectors
  pub type Positions = Vector3fVec;

  /// Dynamic array containing float numbers
  pub type FloatVec = na::DVector<f64>;

  /// A trait provides useful tools for Vec<f64> type.
  pub trait VecFloatMath {
      /// Convert to nalgebra dynamic 1xN vector
      fn to_dvector(&self) -> FloatVec;

      /// 1xN Vector norm
      fn norm(&self) -> f64;
  }

  impl VecFloatMath for [f64] {
      fn to_dvector(&self) -> FloatVec {
          FloatVec::from_column_slice(self.len(), &self)
      }

      fn norm(&self) -> f64 {
          let mut s = 0.0;
          for &x in self {
              s += x.powi(2);
          }

          s.sqrt()
      }
  }

  /// A trait provides useful tools for Vec<[f64; 3]> type.
  pub trait VecFloat3Math {
      /// Return the Frobenius norm (matrix norm) defined as the square root of
      /// the sum of the absolute squares of its elements.
      fn norm(&self) -> f64;

      /// return the norms of a list of 3D vectors
      fn norms(&self) -> Vec<f64>;

      /// Return a 1-D array, containing the elements of 3xN array
      fn ravel(&self) -> Vec<f64>;

      /// Convert to 3xN dynamic matrix
      fn to_dmatrix(&self) -> Vector3fVec;
  }

  // impl VecFloat3Math for Vec<[f64; 3]> {
  impl VecFloat3Math for [[f64; 3]] {
      fn ravel(&self) -> Vec<f64> {
          let n = self.len();
          let mut r = Vec::with_capacity(3 * n);

          for i in 0..n {
              for j in 0..3 {
                  r.push(self[i][j]);
              }
          }

          r
      }

      fn norm(&self) -> f64 {
          let mut d2: f64 = 0.0;
          for i in 0..self.len() {
              for j in 0..3 {
                  d2 += self[i][j].powi(2);
              }
          }
          d2.sqrt()
      }

      fn norms(&self) -> Vec<f64> {
          let n = self.len();
          let mut norms = Vec::with_capacity(n);

          for i in 0..n {
              let mut l = 0.0;
              for j in 0..3 {
                  let vij = self[i][j];
                  l += vij.powi(2);
              }

              norms.push(l.sqrt());
          }

          norms
      }

      fn to_dmatrix(&self) -> Vector3fVec {
          // FIXME: performance
          let r = self.ravel();
          Vector3fVec::from_column_slice(self.len(), &r)
      }
  }

  #[test]
  fn test_vec_math() {
      let a = vec![1.0, 2.0, 3.0];
      let x = a.to_dvector();
      assert_relative_eq!(x.norm(), a.norm(), epsilon=1e-3);

      let positions = [[-0.131944, -0.282942,  0.315957],
                       [ 0.40122 , -1.210646,  0.315957],
                       [-1.201944, -0.282942,  0.315957],
                       [ 0.543331,  0.892036,  0.315957],
                       [ 0.010167,  1.819741,  0.315957],
                       [ 1.613331,  0.892036,  0.315957]];

      let n = positions.norm();
      let m = positions.to_dmatrix();
      assert_relative_eq!(n, m.norm(), epsilon=1e-4);
      let n = positions.to_vec().norm();

      let x = positions.ravel();
      assert_eq!(positions.len() * 3, x.len());
  }
#+end_src

** stats
:PROPERTIES:
:header-args: :tangle tests/test_stats.rs
:END:
#+begin_src rust
  #![feature(test)]
  extern crate test;


  #[test]
  fn test_stats() {
      use crate::test::stats::Stats;

      let mut x = vec![1.0, 2.0, 0.1];

      let v= x.sum();
      println!("{:#?}", v);

      let v= x.max();
      println!("{:#?}", v);

      let v= x.min();
      println!("{:#?}", v);

      let v= x.mean();
      println!("{:#?}", v);
  }
#+end_src

** trait object
:PROPERTIES:
:header-args: :tangle tests/test_traitobj.rs
:END:
#+name: e717db8c-223b-4342-b637-654513af758b
#+begin_src rust
  trait ChemFile {
      fn parse(&self);
  }

  #[derive(Debug)]
  struct Mol2File();

  impl ChemFile for Mol2File {
      fn parse(&self) { println!("foo1 {:?}", self); }
  }

  #[derive(Debug)]
  struct XYZFile();

  impl ChemFile for XYZFile {
      fn parse(&self) { println!("XYZ {:?}", self); }
  }

  fn guess_chemfile() -> Option<Box<ChemFile>> {
      let mut all: Vec<Box<ChemFile>> = vec![
          Box::new(Mol2File()),
          Box::new(XYZFile()),
      ];

      for p in all {
          p.parse();
          return Some(p)
      }

      None
  }

  #[test]
  fn test_trait() {
      let mut all: Vec<Box<ChemFile>> = vec![
          Box::new(Mol2File()),
          Box::new(XYZFile()),
      ];

      for p in all {
          p.parse();
      }
  }
#+end_src

** nom
:PROPERTIES:
:header-args: :tangle tests/test_nom.rs
:END:
#+name: a2a216f8-6387-4449-aed7-5de45e1c01b1
#+begin_src rust
  #[macro_use]
  extern crate nom;

  #[macro_use]
  extern crate timeit;

  use std::fmt::Debug;
  use nom::IResult;
  use nom::{alphanumeric, multispace, float_s, double_s, digit, anychar};

  // named!(get_name_and_position<&str, (&str, [f32; 3])>,
  //        do_parse!(
  //            name: alphanumeric >>
  //            multispace   >>
  //            x: float_s   >>
  //            multispace   >>
  //            y: float_s   >>
  //            multispace   >>
  //            z: float_s   >>
  //            ((name, [x, y, z]))
  //        )
  // );

  // debug 5.9 µs, release: 569.3 ns
  fn test0(line: &str) -> Vec<f64> {
      let r: Vec<_> = line.split_whitespace().map(|x| x.parse().unwrap()).collect();
      r
  }

  // debug: 32.1 µs, release: 630.4 ns
  named!(test1<&str, Vec<f64>>,
         many_m_n!(3, 3, ws!(double_s))
  );

  // quick and dirty
  named!(maybe_double<&str, f64>,
         // flat_map!(recognize!(is_not_s!(" \t")), parse_to!(f64))
         map_res!(is_not_s!(" \t"), str::parse)
  );

  // debug: 22.3 µs, release: 475.6 ns
  named!(test2<&str, Vec<f64>>,
         many_m_n!(3, 3, ws!(maybe_double))
  );

  // debug: 20.1 µs, release: 388.7 ns
  named!(test3<&str, (f64, f64, f64)>,
         tuple!(
             ws!(maybe_double),
             ws!(maybe_double),
             ws!(maybe_double)
         )
  );

  // debug: 20.1 µs, release: 385.4 ns
  named!(test4<&str, [f64; 3]>,
         do_parse!(
             x: ws!(maybe_double) >>
             y: ws!(maybe_double) >>
             z: ws!(maybe_double) >>
             ([x, y, z])
         )
  );

  //
  fn dump<T: Debug>(res: IResult<&str,T>) {
      match res {
          IResult::Done(rest, value) => {
              println!("Done => value: {:?} rest: {:?}", value, rest)
          },
          IResult::Error(err) => {println!("Err => {:?}", err)},
          IResult::Incomplete(needed) => {println!("Needed => {:?}", needed)}
      }
  }

  #[test]
  fn test_named() {
      let line = "3                 1.49136679   -7.04246937   -3.37298245\r\n";
      // let line = "H31.49136679-7.04246937-3.37298245\r\n";
      // let x = get_name_and_position(line);

      // let x = test("# Timestep 100\n");
      let x = test4(" 1.2 2.1 3.3 x");
      dump(x);

      timeit!({
          let x = test0("1.2 2.1 3.3");
      });

      timeit!({
          let x = test1("1.2 2.1 3.3");
      });

      timeit!({
          let x = test2("1.2 2.1 3.3");
      });

      timeit!({
          let x = test3("1.2 2.1 3.3");
      });

      timeit!({
          let x = test4("1.2 2.1 3.3");
      });
  }
#+end_src

** scratch
#+name: 26fc6fdf-a306-4357-aa27-ceeb00164a2d
#+begin_src shell :results output
  cargo run
#+end_src

** hamming distance
*** test
#+name: 18144448-0970-4f66-bbd3-f206635ba2cf
#+begin_src shell :results output
  cd exercism/rust/hamming
  cargo test -- --nocapture
#+end_src

#+RESULTS: 18144448-0970-4f66-bbd3-f206635ba2cf
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 7 tests
test test_first_string_is_longer ... ok
test test_complete_hamming_distance_in_small_strand ... ok
test test_larger_distance ... ok
test test_no_difference_between_empty_strands ... ok
test test_no_difference_between_identical_strands ... ok
test test_second_string_is_longer ... ok
test test_small_hamming_distance_in_the_middle_somewhere ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/hamming/src/lib.rs
:END:

#+name: 86e0273f-d292-4c9a-a644-a82b07625639
#+begin_src rust
  pub fn hamming_distance(s1: &str, s2: &str) -> Result <usize, String> {
      if s1.len() != s2.len() {
          return Err("err".to_string())
      } else {
          let l = get_hamming_distance(s1, s2);
          Ok(l)
      }
  }

  fn get_hamming_distance(s1: &str, s2: &str) -> usize {
      assert_eq!(s1.len(), s2.len());

      let mut sum = 0;
      for (c1, c2) in s1.chars().zip(s2.chars()) {
          if c1 != c2 {
              sum += 1;
          }
      }
      sum
  }
#+end_src

** reverse string
*** test
#+name: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_src shell :results output
  cd exercism/rust/reverse*
  cargo test
#+end_src

#+RESULTS: 404ac282-7c49-4a99-8cbf-e5cf4a2952f6
#+begin_example

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 5 tests
test test_a_capitalized_word ... ignored
test test_a_palindrome ... ignored
test test_a_sentence_with_punctuation ... ignored
test test_a_word ... ignored
test test_empty_string ... ok

test result: ok. 1 passed; 0 failed; 4 ignored; 0 measured; 0 filtered out


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

#+end_example

*** src
:PROPERTIES:
:header-args: :tangle exercism/rust/reverse-string/src/lib.rs
:END:

#+name: 3d017385-a2ca-49af-8494-9b2dd4569f24
#+begin_src rust
  pub fn reverse(s: &str) -> String {
      s.chars().rev().collect::<String>()
  }
#+end_src
* References
- [[https://rust-lang-nursery.github.io/rust-cookbook/basics.html][Rust Cookbook]]
- [[http://stevedonovan.github.io/rust-gentle-intro/readme.html][Introduction - A Gentle Introduction to Rust]]
- [[https://rustbyexample.com/][Introduction - Rust By Example]]
- [[https://learnxinyminutes.com/docs/rust/][Learn rust in Y Minutes]]

* Local variables
# Emacs:
# Local Variables:
# mode: org
# end:
